<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Onelist AI Memory Evolution: Comprehensive Planning Document - Onelist Roadmap</title>
  <style>
    :root {
      --bg: #0a0a0a;
      --card-bg: #141414;
      --border: #2a2a2a;
      --text: #e0e0e0;
      --text-muted: #888;
      --accent: #3b82f6;
      --accent-hover: #60a5fa;
      --code-bg: #1a1a1a;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.7;
      padding: 2rem;
      max-width: 900px;
      margin: 0 auto;
    }
    
    .back-link {
      display: inline-block;
      margin-bottom: 2rem;
      color: var(--accent);
      text-decoration: none;
    }
    .back-link:hover { color: var(--accent-hover); }
    
    h1 { font-size: 2rem; margin-bottom: 0.5rem; }
    h2 { font-size: 1.5rem; margin-top: 2rem; margin-bottom: 1rem; border-bottom: 1px solid var(--border); padding-bottom: 0.5rem; }
    h3 { font-size: 1.25rem; margin-top: 1.5rem; margin-bottom: 0.75rem; }
    h4 { font-size: 1.1rem; margin-top: 1.25rem; margin-bottom: 0.5rem; }
    
    p { margin-bottom: 1rem; }
    
    a { color: var(--accent); }
    a:hover { color: var(--accent-hover); }
    
    code {
      background: var(--code-bg);
      padding: 0.2rem 0.4rem;
      border-radius: 0.25rem;
      font-size: 0.9em;
      font-family: 'SF Mono', Monaco, monospace;
    }
    
    pre {
      background: var(--code-bg);
      padding: 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      margin-bottom: 1rem;
    }
    pre code {
      background: none;
      padding: 0;
    }
    
    ul, ol { margin-bottom: 1rem; padding-left: 1.5rem; }
    li { margin-bottom: 0.5rem; }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 1rem;
    }
    th, td {
      border: 1px solid var(--border);
      padding: 0.5rem 0.75rem;
      text-align: left;
    }
    th { background: var(--card-bg); }
    
    blockquote {
      border-left: 3px solid var(--accent);
      padding-left: 1rem;
      margin: 1rem 0;
      color: var(--text-muted);
    }
    
    hr {
      border: none;
      border-top: 1px solid var(--border);
      margin: 2rem 0;
    }
    
    .meta {
      color: var(--text-muted);
      font-size: 0.875rem;
      margin-bottom: 2rem;
    }
  </style>
</head>
<body>
  <a href="/roadmap/" class="back-link">← Back to Roadmap Index</a>
  
  <article>
    <h1>Onelist AI Memory Evolution: Comprehensive Planning Document</h1>
<strong>Created</strong>: 2026-01-28
<strong>Last Updated</strong>: 2026-01-28
<strong>Status</strong>: Active Planning
<hr>
<h2>Table of Contents</h2>
<p>1. <a href="#1-vision--goals">Vision & Goals</a>
2. <a href="#2-architecture-overview">Architecture Overview</a>
3. <a href="#3-core-technical-requirements">Core Technical Requirements</a>
4. <a href="#4-schema-evolution">Schema Evolution</a>
5. <a href="#5-api-design">API Design</a>
6. <a href="#6-openclaw-compatibility">OpenClaw Compatibility</a>
7. <a href="#7-sync-protocol">Sync Protocol</a>
8. <a href="#8-end-to-end-encryption">End-to-End Encryption</a>
9. <a href="#9-search--retrieval">Search & Retrieval</a>
10. <a href="#10-memory-management">Memory Management</a>
11. <a href="#11-performance-considerations">Performance Considerations</a>
12. <a href="#12-security-considerations">Security Considerations</a>
13. <a href="#13-business--licensing">Business & Licensing</a>
14. <a href="#14-migration--compatibility">Migration & Compatibility</a>
15. <a href="#15-open-questions">Open Questions</a>
16. <a href="#16-risk-register">Risk Register</a>
17. <a href="#17-opportunity-register">Opportunity Register</a>
18. <a href="#18-dependencies-on-existing-plan">Dependencies on Existing Plan</a>
19. <a href="#19-phasing--prioritization">Phasing & Prioritization</a>
20. <a href="#20-decision-log">Decision Log</a></p>
<hr>
<h2>1. Vision & Goals</h2>
<h3>1.1 Core Vision</h3>
Onelist becomes the <strong>universal second brain for both AI agents and humans</strong> — a self-hostable, open-source memory infrastructure that can:
<ul>
<li>Serve as drop-in replacement for OpenClaw's file-based memory</li>
<li>Support hybrid local/cloud architecture with E2EE</li>
<li>Enable multiple AI agent instances to share a synchronized memory store</li>
<li>Remain useful for humans directly (notes, memories, knowledge management)</li>
<h3>1.2 Strategic Goals</h3>
<li>[ ] <strong>Open Source First Mover</strong>: Release as open source, establish hosting infrastructure as primary business model</li>
<li>[ ] <strong>OpenClaw Compatibility</strong>: Drop-in replacement via API or skill</li>
<li>[ ] <strong>True Privacy</strong>: E2EE ensures even cloud hosting can't read user memories</li>
<li>[ ] <strong>Multi-Client Sync</strong>: Multiple OpenClaw/agent instances can push/pull to shared cloud</li>
<li>[ ] <strong>Dual Audience</strong>: Serve both AI agents (API) and humans (Web UI)</li>
<h3>1.3 Non-Goals (for initial release)</h3>
<li>Cloud-based search (search only works locally)</li>
<li>Real-time collaborative editing between agents</li>
<li>Enterprise/team features (focus on personal use first)</li>
<hr>
<h2>2. Architecture Overview</h2>
<h3>2.1 Core Paradigm: Storage vs. Intelligence</h3>
<strong>CRITICAL DESIGN PRINCIPLE</strong>: Onelist Core is <strong>storage infrastructure</strong>. Intelligence resides in <strong>agents</strong>.
<p>This aligns with the existing Onelist daemon architecture where agents (Feeder, Reader, Librarian,
Searcher, Jarvis, Xamlr, etc.) provide intelligence while Onelist Core provides storage and API access.</p>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                           INTELLIGENCE LAYER (Agents)                        │
│                                                                              │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐          │
│  │ OpenClaw  │ │ Onelist  │ │ Onelist  │ │ Onelist  │ │  Xamlr   │          │
│  │ (AI Asst)│ │ Reader   │ │ Searcher │ │ Jarvis   │ │ (Blog)   │          │
│  └────┬─────┘ └────┬─────┘ └────┬─────┘ └────┬─────┘ └────┬─────┘          │
│       │            │            │            │            │                 │
│  Agents handle:                                                             │
│  • Embedding generation          • Relevance/decay decisions                │
│  • Compaction/summarization      • Search orchestration                     │
│  • Tag suggestions               • Content analysis                         │
│  • Memory organization           • User interaction                         │
│  • LLM inference                 • Intelligence &amp; reasoning                 │
└───────┼────────────┼────────────┼────────────┼────────────┼─────────────────┘
        │            │            │            │            │
        └────────────┴────────────┼────────────┴────────────┘
                                  │ Onelist API
                                  ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                         STORAGE LAYER (Onelist Core)                         │
│                                                                              │
│  Onelist Core provides:                                                      │
│  • CRUD operations              • Versioning &amp; history                       │
│  • Full-text search (FTS)       • Sync coordination                          │
│  • Vector similarity search     • E2EE at rest/transit                       │
│  • Tagging &amp; filtering          • Authentication &amp; rate limiting             │
│                                                                              │
│  Onelist Core does NOT provide:                                              │
│  • Embedding generation (agents do this)                                     │
│  • Compaction/summarization (agents do this)                                 │
│  • Relevance scoring (agents do this)                                        │
│  • LLM inference (agents do this)                                            │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h4>Existing Planned Agents (from future_roadmap.md)</h4>
<table>
<tr><th>Agent</th><th>Function</th><th>OpenClaw Equivalent</th></tr>
<tr><td><strong>Onelist Feeder</strong></td><td>Fetch external content (RSS, etc.)</td><td>—</td></tr>
<tr><td><strong>Onelist Reader</strong></td><td>Summarize, extract key phrases, suggest tags</td><td>Memory compaction</td></tr>
<tr><td><strong>Onelist Librarian</strong></td><td>Analyze tags, suggest merges/splits</td><td>Memory organization</td></tr>
<tr><td><strong>Onelist Researcher</strong></td><td>Retrieve related external content</td><td>—</td></tr>
<tr><td><strong>Onelist Writer</strong></td><td>AI writing assistance</td><td>—</td></tr>
<tr><td><strong>Onelist Planner</strong></td><td>Identify actionable items, create plans</td><td>Task extraction</td></tr>
<tr><td><strong>Onelist Jarvis</strong></td><td>NLQ over entries, synthesis, briefing</td><td>Memory recall</td></tr>
<tr><td><strong>Onelist Searcher</strong></td><td>Generate embeddings, semantic search</td><td>Memory search</td></tr>
<tr><td><strong>Xamlr</strong></td><td>Blogging platform</td><td>—</td></tr>
<tr><td><strong>Limitless</strong></td><td>Audio/transcript import</td><td>—</td></tr>
<tr><td><strong>Email</strong></td><td>Email client integration</td><td>—</td></tr>
<tr><td><strong>OpenClaw</strong></td><td>AI assistant with proactive memory</td><td>NEW - fits existing pattern</td></tr>
</table>
<h4>Implications for OpenClaw Integration</h4>
<p>OpenClaw becomes <strong>another agent in the Onelist ecosystem</strong>, not a special case:</p>
<p>1. <strong>OpenClaw calls Onelist API</strong> for storage operations (same as other agents)
2. <strong>OpenClaw generates its own embeddings</strong> and stores them via API
3. <strong>OpenClaw decides compaction strategy</strong> and executes via API
4. <strong>OpenClaw performs search orchestration</strong> (hybrid search is just an API call)
5. <strong>Onelist Searcher daemon could assist</strong> if user wants to offload embedding generation</p>
<p>This means Onelist Core needs:
<li>Robust API for CRUD + search + sync</li>
<li>Vector storage capability (pgvector)</li>
<li>NO built-in embedding generation (optional daemon can provide this)</li>
<li>NO built-in compaction logic (agents decide this)</li></p>
<h3>2.2 Deployment Topology (Multi-Client Sync)</h3>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────┐
│                      ONELIST CLOUD (Hosted) - HEADLESS              │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │  - Encrypted blob storage (can't read content)                │ │
│  │  - Sync coordination (vector clocks / Merkle trees)           │ │
│  │  - Account management, auth, quotas                           │ │
│  │  - S3-compatible asset storage (encrypted)                    │ │
│  │  - NO web UI (headless by design)                             │ │
│  │  - NO search capability (can't search what we can't read)     │ │
│  └───────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────┘
                    ▲                           ▲
                    │ E2EE Sync                 │ E2EE Sync
                    ▼                           ▼
┌─────────────────────────────────────────────────────────────────────┐
│   LOCAL INSTANCE A            │   LOCAL INSTANCE B                  │
│   (e.g., Mac App)             │   (e.g., Home Server)               │
│                               │                                     │
│  ┌─────────────────────────┐  │  ┌─────────────────────────┐       │
│  │  Native App Shell       │  │  │  OpenClaw + Agents       │       │
│  │  (macOS/iOS wrapper)    │  │  │  (headless)             │       │
│  │  ┌───────────────────┐  │  │  └──────────┬──────────────┘       │
│  │  │ Phoenix LiveView  │  │  │             │                      │
│  │  │ (Web UI inside)   │  │  │             ▼                      │
│  │  └─────────┬─────────┘  │  │  ┌─────────────────────────┐       │
│  └────────────┼────────────┘  │  │  Onelist Core (API)     │       │
│               │               │  │  - Full CRUD            │       │
│               ▼               │  │  - Hybrid Search        │       │
│  ┌─────────────────────────┐  │  └──────────┬──────────────┘       │
│  │  Onelist Core (API)     │  │             │                      │
│  │  - Full CRUD            │  │             ▼                      │
│  │  - Hybrid Search        │  │  ┌─────────────────────────┐       │
│  └──────────┬──────────────┘  │  │ PostgreSQL+pgvector     │       │
│             │                 │  │ (Plaintext locally)     │       │
│             ▼                 │  └─────────────────────────┘       │
│  ┌─────────────────────────┐  │                                     │
│  │ PostgreSQL+pgvector     │  │                                     │
│  │ (Embedded, plaintext)   │  │                                     │
│  └─────────────────────────┘  │                                     │
└───────────────────────────────┴─────────────────────────────────────┘
</code></pre>
<h3>2.2.1 Key Deployment Insight: Cloud is Headless</h3>
<strong>The central Onelist cloud has NO web interface.</strong> This is intentional:
<pre><code class="language-">What Cloud Provides:                    What Cloud Does NOT Provide:
─────────────────────                   ────────────────────────────
✓ Encrypted storage (E2EE blobs)        ✗ Web UI / Dashboard
✓ Sync coordination                     ✗ Search functionality
✓ Account management                    ✗ Content rendering
✓ S3 asset storage (encrypted)          ✗ ANY ability to read user data
✓ Billing / quotas                      ✗ Decryption keys
</code></pre>
<strong>Why this matters:</strong>
1. <strong>True privacy</strong> - We literally cannot read user data
2. <strong>Lower cloud costs</strong> - No compute for rendering/searching
3. <strong>Simpler infrastructure</strong> - Just API + blob storage
4. <strong>Trust model</strong> - "Can't be evil" vs "won't be evil"
<h3>2.2.2 Where the Web UI Lives</h3>
<p>The web interface runs <strong>locally</strong>, inside native app shells:</p>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────┐
│                    MAC APP (Onelist.app)                            │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │  Native macOS Shell (Swift/AppKit wrapper)                    │ │
│  │  ┌─────────────────────────────────────────────────────────┐  │ │
│  │  │           Phoenix LiveView (Web UI)                     │  │ │
│  │  │           - Full Onelist interface                      │  │ │
│  │  │           - Runs on localhost                           │  │ │
│  │  │           - Renders in WKWebView                        │  │ │
│  │  └─────────────────────────────────────────────────────────┘  │ │
│  └───────────────────────────────────────────────────────────────┘ │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │  Embedded PostgreSQL (subprocess)                             │ │
│  └───────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────┘
<p>┌─────────────────────────────────────────────────────────────────────┐
│                    iOS APP (Phoenix Native)                         │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │  Phoenix Native (LiveView → Native iOS UI)                    │ │
│  │  - Same Phoenix backend code                                  │ │
│  │  - Renders with native SwiftUI components                     │ │
│  │  - Local PostgreSQL or SQLite (TBD)                           │ │
│  └───────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────┘</p>
<p>┌─────────────────────────────────────────────────────────────────────┐
│                    SELF-HOSTED (Docker)                             │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │  Phoenix Web Server                                           │ │
│  │  - Accessible on LAN: http://192.168.1.x:4000                 │ │
│  │  - Full web UI for any browser                                │ │
│  └───────────────────────────────────────────────────────────────┘ │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │  PostgreSQL Container                                         │ │
│  └───────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────┘
</code></pre></p>
<h3>2.2.3 Premium Tier: Cloud VM with Web Access</h3>
<p>For users who want web access without running local infrastructure:</p>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────┐
│                    PREMIUM: DEDICATED VM TIER                       │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │  User's Dedicated VM (isolated, encrypted at rest)            │ │
│  │                                                                │ │
│  │  ┌─────────────────────────────────────────────────────────┐  │ │
│  │  │  Phoenix Web Server                                     │  │ │
│  │  │  - https://username.onelist.my                          │  │ │
│  │  │  - Full web UI                                          │  │ │
│  │  │  - API access                                           │  │ │
│  │  └─────────────────────────────────────────────────────────┘  │ │
│  │  ┌─────────────────────────────────────────────────────────┐  │ │
│  │  │  PostgreSQL + pgvector                                  │  │ │
│  │  │  - Encrypted volume                                     │  │ │
│  │  │  - User's data isolated                                 │  │ │
│  │  └─────────────────────────────────────────────────────────┘  │ │
│  │  ┌─────────────────────────────────────────────────────────┐  │ │
│  │  │  Optional: Agents (Reader, Searcher, etc.)              │  │ │
│  │  └─────────────────────────────────────────────────────────┘  │ │
│  └───────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────┘
         ▲
         │ HTTPS
         ▼
    ┌─────────┐
    │ Browser │  (User accesses from anywhere)
    └─────────┘
</code></pre>
<strong>Key difference from base tier:</strong>
<li>Base tier: Cloud stores encrypted blobs, UI runs locally</li>
<li>VM tier: Cloud runs full Onelist instance for user (still isolated, E2EE in transit)</li>
<strong>Trust tradeoff:</strong>
<li>Base tier: Zero-knowledge (we can't read your data)</li>
<li>VM tier: Traditional trust model (we <em>could</em> read, but won't; encrypted at rest)</li>
<h3>2.2.4 Domain Structure</h3>
<p>The Onelist cloud infrastructure uses the <code>onelist.my</code> domain:</p>
<table>
<tr><th>Domain</th><th>Purpose</th></tr>
<tr><td><code>onelist.my</code></td><td>Corporate website, marketing, documentation</td></tr>
<tr><td><code>app.onelist.my</code></td><td>Account dashboard, billing, device management</td></tr>
<tr><td><code>[username].onelist.my</code></td><td>VM tier user instances (full web UI)</td></tr>
<tr><td><code>api.onelist.my</code></td><td>Headless cloud API (sync, storage, auth)</td></tr>
</table>
<strong>Architecture:</strong>
<li><strong>Corporate site</strong> (<code>onelist.my</code>): Built with Beacon CMS for Phoenix (see <code>onelist_website_plan.md</code>)</li>
<li><strong>Account portal</strong> (<code>app.onelist.my</code>): User account management, billing via Stripe</li>
<li><strong>User instances</strong> (<code>[username].onelist.my</code>): Full Onelist web UI for VM tier subscribers</li>
<li><strong>API</strong> (<code>api.onelist.my</code>): Headless sync/storage API for all clients</li>
<h3>2.3 Key Architectural Decisions</h3>
<table>
<tr><th>Decision</th><th>Choice</th><th>Rationale</th></tr>
<tr><td>Search location</td><td>Local only</td><td>Enables true E2EE; cloud can't search what it can't read</td></tr>
<tr><td>Encryption scope</td><td>All content E2EE</td><td>Privacy is non-negotiable differentiator</td></tr>
<tr><td>Sync model</td><td>Eventually consistent</td><td>Agents can work offline; sync when available</td></tr>
<tr><td>Storage backend</td><td>PostgreSQL + pgvector</td><td>Already in stack; proven; supports hybrid search</td></tr>
<tr><td>Embedding generation</td><td>Local (configurable)</td><td>Privacy; user chooses model</td></tr>
</table>
<hr>
<h2>3. Core Technical Requirements</h2>
<h3>3.0 What Onelist Core Provides vs. What Agents Provide</h3>
<p>Per the storage-vs-intelligence paradigm, here's the responsibility split:</p>
<table>
<tr><th>Capability</th><th>Onelist Core</th><th>Agents (OpenClaw, Searcher, etc.)</th></tr>
<tr><td><strong>Store entries/memories</strong></td><td>✅ CRUD API</td><td>Calls API</td></tr>
<tr><td><strong>Store embeddings</strong></td><td>✅ Vector column storage</td><td>Generates embeddings, calls API</td></tr>
<tr><td><strong>Full-text search</strong></td><td>✅ FTS query endpoint</td><td>Calls API</td></tr>
<tr><td><strong>Vector similarity search</strong></td><td>✅ pgvector query endpoint</td><td>Calls API, interprets results</td></tr>
<tr><td><strong>Hybrid search orchestration</strong></td><td>❌ (or basic combo)</td><td>✅ Weights, re-ranks, filters</td></tr>
<tr><td><strong>Generate embeddings</strong></td><td>❌</td><td>✅ Uses LLM/embedding API</td></tr>
<tr><td><strong>Compaction/summarization</strong></td><td>❌</td><td>✅ Uses LLM, calls CRUD API</td></tr>
<tr><td><strong>Relevance/decay scoring</strong></td><td>❌</td><td>✅ Calculates, stores in metadata</td></tr>
<tr><td><strong>Memory organization</strong></td><td>❌</td><td>✅ Decides structure, uses tags</td></tr>
<tr><td><strong>Versioning/history</strong></td><td>✅ representation_versions</td><td>Uses API for rollback</td></tr>
<tr><td><strong>Sync coordination</strong></td><td>✅ Cloud sync protocol</td><td>Triggers sync</td></tr>
<tr><td><strong>E2EE</strong></td><td>✅ Encryption layer</td><td>Provides keys</td></tr>
<tr><td><strong>User interaction</strong></td><td>✅ Web UI (for humans)</td><td>✅ Chat UI (for agents)</td></tr>
</table>
<h3>3.1 Essential API Capabilities for AI Memory</h3>
<p>These are what Onelist Core must provide so agents can build memory systems on top.</p>
<h4>3.1.1 Vector Storage (for agent-generated embeddings)</h4>
<li>[ ] Add <code>pgvector</code> extension to PostgreSQL</li>
<li>[ ] API endpoint to store embeddings with entries</li>
<li>[ ] Support configurable embedding dimensions (384, 768, 1536, etc.)</li>
<li>[ ] Batch write support for efficiency</li>
<li>[ ] <strong>NOTE</strong>: Onelist does NOT generate embeddings; agents do this</li>
<strong>Schema Considerations:</strong>
<pre><code class="language-sql">-- Option A: Store in representations table
ALTER TABLE representations ADD COLUMN embedding vector(1536);
<p>-- Option B: Dedicated embeddings table (more flexible)
CREATE TABLE embeddings (
  id UUID PRIMARY KEY,
  representation_id UUID REFERENCES representations(id),
  model_name VARCHAR(255) NOT NULL,  -- e.g., 'text-embedding-3-small'
  dimensions INTEGER NOT NULL,
  vector vector(1536),  -- or use varying dimensions
  inserted_at TIMESTAMPTZ NOT NULL,
  metadata JSONB  -- model version, parameters, etc.
);
</code></pre></p>
<strong>Open Questions:</strong>
<li>[ ] Single embedding per representation or multiple (different models)?</li>
<li>[ ] How to handle embedding model upgrades/changes?</li>
<li>[ ] Should embeddings be versioned separately from content?</li>
<h4>3.1.2 Hybrid Search API</h4>
<li>[ ] Combine FTS (<code>tsvector</code>) with vector similarity in single query</li>
<li>[ ] Configurable weighting between semantic and keyword results</li>
<li>[ ] Support for filtered search (by entry_type, tags, date range, etc.)</li>
<li>[ ] Relevance scoring that combines both signals</li>
<li>[ ] Pagination with consistent ordering</li>
<strong>API Shape (draft):</strong>
<pre><code class="language-elixir"># POST /api/v1/memory/search
%{
  &quot;query&quot; =&gt; &quot;what did I discuss about the project deadline&quot;,
  &quot;search_type&quot; =&gt; &quot;hybrid&quot;,  # &quot;semantic&quot;, &quot;keyword&quot;, &quot;hybrid&quot;
  &quot;weights&quot; =&gt; %{&quot;semantic&quot; =&gt; 0.7, &quot;keyword&quot; =&gt; 0.3},
  &quot;filters&quot; =&gt; %{
    &quot;entry_types&quot; =&gt; [&quot;memory_episode&quot;, &quot;memory_fact&quot;],
    &quot;tags&quot; =&gt; [&quot;work&quot;],
    &quot;date_range&quot; =&gt; %{&quot;from&quot; =&gt; &quot;2026-01-01&quot;, &quot;to&quot; =&gt; &quot;2026-01-28&quot;}
  },
  &quot;limit&quot; =&gt; 20,
  &quot;offset&quot; =&gt; 0,
  &quot;include_embeddings&quot; =&gt; false
}
</code></pre>
<strong>Technical Challenges:</strong>
<li>[ ] Efficient query planning for hybrid search</li>
<li>[ ] Score normalization between FTS and vector similarity</li>
<li>[ ] Index optimization (GIN for FTS, IVFFlat/HNSW for vectors)</li>
<h4>3.1.3 Memory-Specific Entry Types</h4>
<li>[ ] <code>memory_episode</code> — Time-bound experiences, conversations, events</li>
<li>[ ] <code>memory_fact</code> — Durable knowledge, preferences, core truths</li>
<li>[ ] <code>memory_profile</code> — User model, behavioral patterns, inferred traits</li>
<li>[ ] <code>memory_task</code> — Pending actions, reminders, goals</li>
<li>[ ] <code>memory_observation</code> — Agent observations, environmental data</li>
<strong>Behavioral Differences by Type:</strong>
<table>
<tr><th>Type</th><th>Mutability</th><th>Decay</th><th>Compaction</th><th>Versioning</th></tr>
<tr><td><code>memory_episode</code></td><td>Immutable after creation</td><td>Yes (configurable)</td><td>Summarize older episodes</td><td>No</td></tr>
<tr><td><code>memory_fact</code></td><td>Mutable (can be corrected)</td><td>No</td><td>Merge duplicates</td><td>Yes</td></tr>
<tr><td><code>memory_profile</code></td><td>Continuously updated</td><td>No</td><td>Rolling window</td><td>Yes</td></tr>
<tr><td><code>memory_task</code></td><td>Mutable until complete</td><td>Yes (after completion)</td><td>Archive completed</td><td>Yes</td></tr>
<tr><td><code>memory_observation</code></td><td>Immutable</td><td>Yes (aggressive)</td><td>Aggregate/summarize</td><td>No</td></tr>
</table>
<h4>3.1.4 Memory Management API (for agent-driven compaction)</h4>
<strong>IMPORTANT</strong>: Per the storage-vs-intelligence paradigm, compaction/summarization is an <strong>agent responsibility</strong>, not Onelist Core. Onelist Core provides the API operations agents need to implement compaction.
<strong>What Onelist Core Provides:</strong>
<li>[ ] Bulk read API (get memories by date range, type, etc.)</li>
<li>[ ] Bulk write API (create summaries, archive originals)</li>
<li>[ ] Soft delete / archive API (mark entries as archived)</li>
<li>[ ] Metadata update API (update decay scores, access counts)</li>
<li>[ ] Entry linking API (link summary to source entries)</li>
<strong>What Agents Do (examples):</strong>
<li><strong>OpenClaw</strong>: Runs its own compaction logic, uses CRUD API</li>
<li><strong>Onelist Reader daemon</strong>: Could provide compaction-as-a-service</li>
<li><strong>Custom agent</strong>: User can build their own compaction strategy</li>
<strong>Example Agent Workflow (OpenClaw compaction):</strong>
<pre><code class="language-">1. OpenClaw queries: GET /api/v1/memory?entry_type=memory_episode&amp;older_than=7d
2. OpenClaw generates summary using its LLM
3. OpenClaw stores summary: POST /api/v1/memory {entry_type: memory_summary}
4. OpenClaw links summary to sources: POST /api/v1/memory/:id/links
5. OpenClaw archives originals: PATCH /api/v1/memory/:id {archived: true}
</code></pre>
<strong>Optional Onelist Daemons (separate from Core):</strong>
Users who want turnkey compaction could run optional daemons:
<li><code>Onelist.Daemons.Reader</code> — Summarization service</li>
<li><code>Onelist.Daemons.Searcher</code> — Embedding generation service</li>
<li>These are separate deployable services, not part of Core</li>
<strong>Challenges:</strong>
<li>[ ] Agents need sufficient API capabilities</li>
<li>[ ] Race conditions if multiple agents compact simultaneously</li>
<li>[ ] Clear documentation for agent developers</li>
<h4>3.1.5 Relevance/Decay Scoring</h4>
<li>[ ] Recency factor (newer = more relevant)</li>
<li>[ ] Access frequency (frequently retrieved = more relevant)</li>
<li>[ ] Explicit importance markers (user can pin/star)</li>
<li>[ ] Source reliability weighting</li>
<li>[ ] Configurable decay curves per entry type</li>
<strong>Metadata Fields:</strong>
<pre><code class="language-elixir">%{
  &quot;relevance&quot; =&gt; %{
    &quot;access_count&quot; =&gt; 42,
    &quot;last_accessed_at&quot; =&gt; &quot;2026-01-28T10:30:00Z&quot;,
    &quot;importance&quot; =&gt; &quot;high&quot;,  # user-set
    &quot;decay_rate&quot; =&gt; 0.1,     # per-day decay factor
    &quot;pinned&quot; =&gt; true
  }
}
</code></pre>
<h3>3.2 Nice to Have (Phase 2+)</h3>
<h4>3.2.1 Encryption at Rest (Local)</h4>
<li>[ ] Encrypt PostgreSQL data files</li>
<li>[ ] Or: Application-level encryption before DB write</li>
<li>[ ] Key derivation from user master password</li>
<h4>3.2.2 Bulk API Operations</h4>
<li>[ ] Batch create memories</li>
<li>[ ] Batch search (multiple queries in one request)</li>
<li>[ ] Streaming responses for large result sets</li>
<li>[ ] Bulk export/import</li>
<h4>3.2.3 Webhook Events</h4>
<li>[ ] Memory created/updated/deleted</li>
<li>[ ] Compaction completed</li>
<li>[ ] Sync status changes</li>
<li>[ ] Search performed (for analytics)</li>
<h4>3.2.4 Memory Budget/Quota Tracking</h4>
<li>[ ] Track storage usage per user</li>
<li>[ ] Configurable limits (self-hosted: unlimited; cloud: tiered)</li>
<li>[ ] Alerts when approaching limits</li>
<li>[ ] Automatic archival suggestions</li>
<hr>
<h2>3.5 Agent Ecosystem Mapping</h2>
<p>This section maps out how different agents (existing planned + OpenClaw) interact with Onelist Core.</p>
<h3>3.5.1 Agent Categories</h3>
<strong>Category A: External AI Assistants (like OpenClaw)</strong>
<li>Run independently of Onelist infrastructure</li>
<li>Use Onelist purely as storage backend</li>
<li>Bring their own LLM, embedding, and reasoning capabilities</li>
<li>Examples: OpenClaw, custom Claude/GPT agents, home automation AI</li>
<strong>Category B: Onelist Daemons (optional services)</strong>
<li>Designed to extend Onelist capabilities</li>
<li>Can be deployed alongside Onelist Core or separately</li>
<li>Provide "batteries included" intelligence for users who want turnkey solution</li>
<li>Examples: Onelist Searcher, Onelist Reader, Onelist Jarvis</li>
<strong>Category C: Onelist Feature Apps (like Xamlr)</strong>
<li>Full applications built on Onelist API</li>
<li>Have their own databases for app-specific data</li>
<li>Use Onelist as content/identity backend</li>
<li>Examples: Xamlr (blogging), Email integration, potential chat apps</li>
<h3>3.5.2 Agent Responsibility Matrix</h3>
<table>
<tr><th>Agent</th><th>Stores Data</th><th>Generates Embeddings</th><th>Compacts/Summarizes</th><th>Searches</th><th>UI</th></tr>
<tr><td><strong>OpenClaw</strong></td><td>Via API</td><td>Yes (its LLM)</td><td>Yes (its logic)</td><td>Via API</td><td>Chat</td></tr>
<tr><td><strong>Onelist Searcher</strong></td><td>Via API</td><td>Yes (service)</td><td>No</td><td>N/A</td><td>None</td></tr>
<tr><td><strong>Onelist Reader</strong></td><td>Via API</td><td>No</td><td>Yes (service)</td><td>No</td><td>None</td></tr>
<tr><td><strong>Onelist Jarvis</strong></td><td>Via API</td><td>Maybe</td><td>Maybe</td><td>Yes (orchestrates)</td><td>Chat</td></tr>
<tr><td><strong>Xamlr</strong></td><td>Own DB + API</td><td>No</td><td>No</td><td>Via API</td><td>Web</td></tr>
<tr><td><strong>Human (Web UI)</strong></td><td>Via UI</td><td>No</td><td>No</td><td>Via UI</td><td>Web</td></tr>
</table>
<h3>3.5.3 OpenClaw Integration Patterns</h3>
<strong>Pattern A: OpenClaw as Primary Agent (Recommended)</strong>
<pre><code class="language-">┌─────────────────┐
│    OpenClaw      │  ← User interacts via Telegram/Discord/etc.
│  (Full Agent)   │
│                 │
│ • LLM reasoning │
│ • Embedding gen │
│ • Compaction    │
│ • Search logic  │
└────────┬────────┘
         │ Onelist API
         ▼
┌─────────────────┐
│  Onelist Core   │  ← Pure storage + basic search
│                 │
│ • CRUD          │
│ • FTS           │
│ • Vector search │
│ • Sync          │
└─────────────────┘
</code></pre>
<strong>Pattern B: OpenClaw + Onelist Daemons (Hybrid)</strong>
<pre><code class="language-">┌─────────────────┐     ┌─────────────────┐
│    OpenClaw      │     │ Onelist Searcher│  ← Offload embedding generation
│  (Lean Agent)   │     │    (Daemon)     │
└────────┬────────┘     └────────┬────────┘
         │                       │
         └───────────┬───────────┘
                     │ Onelist API
                     ▼
             ┌───────────────┐
             │ Onelist Core  │
             └───────────────┘
</code></pre>
<strong>Pattern C: Multiple Agents (Multi-Client)</strong>
<pre><code class="language-">┌──────────┐  ┌──────────┐  ┌──────────┐
│ OpenClaw  │  │ OpenClaw  │  │  Xamlr   │
│ (Home)   │  │ (Work)   │  │ (Blog)   │
└────┬─────┘  └────┬─────┘  └────┬─────┘
     │             │             │
     └─────────────┼─────────────┘
                   │ Onelist API (local instances)
                   ▼
     ┌─────────────────────────────┐
     │   Onelist Cloud (E2EE)      │  ← Sync coordination only
     └─────────────────────────────┘
</code></pre>
<h3>3.5.4 API Requirements by Agent Type</h3>
<strong>For OpenClaw (and similar AI assistants):</strong>
<li>[ ] Memory write with optional embedding: <code>POST /api/v1/memory</code></li>
<li>[ ] Memory search (FTS + vector): <code>POST /api/v1/memory/search</code></li>
<li>[ ] Bulk operations: <code>POST /api/v1/memory/bulk</code></li>
<li>[ ] Metadata updates: <code>PATCH /api/v1/memory/:id</code></li>
<li>[ ] Archive/soft-delete: <code>DELETE /api/v1/memory/:id?soft=true</code></li>
<li>[ ] Entry linking: <code>POST /api/v1/memory/:id/links</code></li>
<li>[ ] Tag management: Standard tag CRUD</li>
<strong>For Onelist Daemons:</strong>
<li>[ ] Webhook subscriptions: <code>POST /api/v1/webhooks</code></li>
<li>[ ] Batch processing: <code>GET /api/v1/memory?needs_embedding=true</code></li>
<li>[ ] Service-to-service auth: API keys with daemon scopes</li>
<strong>For Feature Apps (Xamlr-style):</strong>
<li>[ ] OAuth2 for user authentication</li>
<li>[ ] Full entry/representation/asset CRUD</li>
<li>[ ] Query by metadata fields</li>
<li>[ ] Cursor-based pagination</li>
<hr>
<h2>3.6 Storage Architecture & Local Optimization</h2>
<h3>3.6.1 The Local Storage Challenge</h3>
<p>Since cloud storage is E2EE (and thus unsearchable), local instances must have unencrypted copies of searchable content. This creates a storage challenge as memory grows.</p>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                         STORAGE REALITY                                     │
│                                                                              │
│  CLOUD (E2EE):                     LOCAL (Unencrypted):                     │
│  ┌─────────────────────┐           ┌─────────────────────┐                  │
│  │ • Encrypted blobs   │           │ • Text content ✓    │ ← Searchable    │
│  │ • Can't search      │  sync     │ • Embeddings ✓      │ ← Searchable    │
│  │ • Can't read        │ ◄─────►   │ • Metadata ✓        │ ← Filterable    │
│  │ • Backup only       │           │ • Media ???         │ ← Problem!      │
│  └─────────────────────┘           └─────────────────────┘                  │
│                                                                              │
│  Problem: If we sync everything locally, storage explodes with media        │
│  Solution: Tiered storage - not everything needs to be local                │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3>3.6.2 Tiered Storage Strategy</h3>
<strong>Principle</strong>: Only store locally what's needed for search. Media can stay in cloud.
<table>
<tr><th>Tier</th><th>Content Type</th><th>Local Storage</th><th>Cloud Storage</th><th>Rationale</th></tr>
<tr><td><strong>T1: Always Local</strong></td><td>Text content, embeddings, metadata</td><td>✅ Full</td><td>✅ Encrypted</td><td>Required for search</td></tr>
<tr><td><strong>T2: Local Stubs</strong></td><td>Images, videos, audio</td><td>✅ Thumbnail + metadata</td><td>✅ Full encrypted</td><td>Search by metadata, view on demand</td></tr>
<tr><td><strong>T3: Cloud-Primary</strong></td><td>Large archives, raw backups</td><td>❌ Not synced</td><td>✅ Full encrypted</td><td>Access via cloud only</td></tr>
</table>
<strong>How T2 (Local Stubs) Works:</strong>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                         MEDIA STUB STRATEGY                                 │
│                                                                              │
│  User saves photo (5MB):                                                    │
│                                                                              │
│  LOCAL INSTANCE:                   CLOUD:                                   │
│  ┌─────────────────────┐           ┌─────────────────────┐                  │
│  │ entries record      │           │ Encrypted full      │                  │
│  │ • title, tags       │           │ photo (5MB)         │                  │
│  │ • content_created_at│           │                     │                  │
│  │ • metadata (EXIF)   │           │ Encrypted           │                  │
│  │                     │           │ thumbnail           │                  │
│  │ assets record       │           │                     │                  │
│  │ • thumbnail (50KB)  │           │                     │                  │
│  │ • storage_type:     │           │                     │                  │
│  │   &quot;cloud_stub&quot;      │           │                     │                  │
│  │ • cloud_asset_id    │           │                     │                  │
│  └─────────────────────┘           └─────────────────────┘                  │
│                                                                              │
│  Search works on metadata + tags (local)                                    │
│  View thumbnail (local, instant)                                            │
│  View full image (fetch from cloud, decrypt, cache temporarily)             │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<strong>Storage Estimates (100k memories):</strong>
<table>
<tr><th>Content Type</th><th>Full Storage</th><th>With Tiering</th><th>Savings</th></tr>
<tr><td>Text memories</td><td>500 MB</td><td>500 MB</td><td>0%</td></tr>
<tr><td>Embeddings (1536-dim)</td><td>600 MB</td><td>600 MB</td><td>0%</td></tr>
<tr><td>Metadata/indexes</td><td>200 MB</td><td>200 MB</td><td>0%</td></tr>
<tr><td>Photos (1000 @ 5MB each)</td><td>5 GB</td><td>50 MB (thumbs)</td><td>99%</td></tr>
<tr><td>Videos (100 @ 100MB each)</td><td>10 GB</td><td>10 MB (thumbs)</td><td>99.9%</td></tr>
<tr><td><strong>Total</strong></td><td><strong>~16 GB</strong></td><td><strong>~1.4 GB</strong></td><td><strong>91%</strong></td></tr>
</table>
<h3>3.6.3 Sync Modes</h3>
<p>Users can choose their sync mode based on device storage:</p>
<table>
<tr><th>Mode</th><th>Local Storage</th><th>Use Case</th></tr>
<tr><td><strong>Full Sync</strong></td><td>Everything including media</td><td>Desktop with storage, primary device</td></tr>
<tr><td><strong>Lean Sync</strong></td><td>Text + embeddings + thumbnails</td><td>Laptop, secondary device</td></tr>
<tr><td><strong>Minimal Sync</strong></td><td>Text + metadata only (no embeddings)</td><td>Mobile, storage-constrained</td></tr>
<tr><td><strong>Search-Only</strong></td><td>Embeddings + metadata (no content)</td><td>Dedicated search node</td></tr>
</table>
<pre><code class="language-elixir"># User config
config :onelist, :sync_mode, :lean  # or :full, :minimal, :search_only
<h1>Affects what gets synced</h1>
defmodule Onelist.Sync do
  def should_sync_locally?(asset, mode) do
    case {asset.type, mode} do
      {_, :full} -&gt; true
      {:thumbnail, :lean} -&gt; true
      {:full_media, :lean} -&gt; false
      {:text, _} -&gt; true
      {:embedding, :minimal} -&gt; false
      {_, :minimal} -&gt; is_text_or_metadata?(asset)
      # etc.
    end
  end
end
</code></pre>
<h3>3.6.4 Asset Storage Backend Integration</h3>
<strong>Reference:</strong> See <code>roadmap/asset_storage_plan.md</code> for full implementation details.
<p>The asset storage system provides the foundation for tiered sync with E2EE:</p>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                    ASSET STORAGE ARCHITECTURE                               │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                     Storage Facade                                   │    │
│  │  store() → retrieve() → presigned_url() → delete()                  │    │
│  └───────────────────────────────┬─────────────────────────────────────┘    │
│                                  │                                          │
│         ┌────────────────────────┼────────────────────────┐                 │
│         ▼                        ▼                        ▼                 │
│  ┌─────────────┐    ┌───────────────────────┐    ┌─────────────┐           │
│  │   Local     │    │    Encrypted S3       │    │    GCS      │           │
│  │  Backend    │    │    (R2/B2/AWS/etc)    │    │  Backend    │           │
│  └─────────────┘    └───────────────────────┘    └─────────────┘           │
│                              │                                              │
│                              ▼                                              │
│                     ┌─────────────────┐                                     │
│                     │  E2EE Wrapper   │                                     │
│                     │  (encrypt/      │                                     │
│                     │   decrypt)      │                                     │
│                     └─────────────────┘                                     │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<strong>Backend Configuration by Deployment:</strong>
<table>
<tr><th>Deployment</th><th>Primary</th><th>Mirror</th><th>E2EE</th><th>Tiered Sync</th></tr>
<tr><td>Mac App (Tier 1)</td><td><code>:local</code></td><td><code>[:encrypted_s3]</code></td><td>Yes</td><td>Yes</td></tr>
<tr><td>Self-hosted Docker</td><td><code>:local</code></td><td><code>[:encrypted_s3]</code></td><td>Yes</td><td>Optional</td></tr>
<tr><td>VM Tier</td><td><code>:s3</code></td><td><code>[:local]</code></td><td>No</td><td>No</td></tr>
<tr><td>OpenClaw Sidecar</td><td><code>:local</code></td><td><code>[:encrypted_s3]</code></td><td>Yes</td><td>Yes</td></tr>
</table>
<h3>3.6.5 BYOB (Bring Your Own Bucket)</h3>
<blockquote><strong>Note:</strong> BYOB backend support is MVP (being implemented separately). User-facing UI for paid plans is post-MVP.</blockquote>
<p>Users can connect their own cloud storage instead of using Onelist-provided storage:</p>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                    STORAGE OPTIONS                                          │
│                                                                              │
│  Option A: Onelist Cloud (Default)           Option B: BYOB                 │
│  ┌─────────────────────────────┐             ┌─────────────────────────────┐│
│  │  • We manage R2 bucket      │             │  • User's own bucket        ││
│  │  • $0.02-0.03/GB/mo         │             │  • $0 from Onelist          ││
│  │  • Included in Tier 1 price │             │  • User pays provider       ││
│  │  • Zero setup               │             │  • Full data control        ││
│  └─────────────────────────────┘             └─────────────────────────────┘│
│                                                                              │
│  Supported BYOB Providers:                                                  │
│  • Cloudflare R2 (recommended - no egress fees)                             │
│  • Backblaze B2 (lowest cost)                                               │
│  • AWS S3 (enterprise)                                                      │
│  • DigitalOcean Spaces                                                      │
│  • Wasabi (no egress fees)                                                  │
│  • MinIO (self-hosted)                                                      │
│  • Any S3-compatible service                                                │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<strong>BYOB Benefits:</strong>
<li><strong>For users</strong>: Data sovereignty, use existing cloud credits, potentially lower costs</li>
<li><strong>For Onelist</strong>: Lower infrastructure costs, reduced data liability</li>
<strong>Schema:</strong> <code>user_storage_configs</code> table stores encrypted BYOB credentials per user.
<h3>3.6.6 OpenClaw Asset Integration</h3>
<p>OpenClaw may capture screenshots, audio recordings, or user-shared files. These integrate via the sidecar:</p>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                    OPENCLAW ASSET FLOW                                       │
│                                                                              │
│  1. OpenClaw captures screenshot                                             │
│     └─→ Saves to: ~/openclaw/assets/2026-01-28/screenshot_1030.png          │
│                                                                              │
│  2. Onelist File Watcher (sidecar) detects new file                         │
│     └─→ Creates memory entry (entry_type: 'memory_screenshot')              │
│     └─→ Calls Storage.store() with file content                             │
│                                                                              │
│  3. Storage layer handles it:                                               │
│     └─→ Primary (local): Stores thumbnail + metadata                        │
│     └─→ Mirror (encrypted_s3): Encrypts full file, uploads async            │
│                                                                              │
│  4. Optional: Delete original OpenClaw file to save space                    │
│     └─→ Configurable: keep_openclaw_originals: true/false                    │
│                                                                              │
│  5. Search works on:                                                        │
│     └─→ Metadata (timestamp, dimensions, etc.)                              │
│     └─→ Tags (if added by user or daemon)                                   │
│     └─→ OCR text (if Reader daemon extracts it)                             │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<strong>OpenClaw Asset Types:</strong>
<table>
<tr><th>Type</th><th>Entry Type</th><th>Local Storage</th><th>Cloud Storage</th></tr>
<tr><td>Screenshot</td><td><code>memory_screenshot</code></td><td>Thumbnail</td><td>Full (E2EE)</td></tr>
<tr><td>Audio recording</td><td><code>memory_audio</code></td><td>Waveform preview</td><td>Full (E2EE)</td></tr>
<tr><td>User attachment</td><td><code>memory_attachment</code></td><td>Depends on size</td><td>Full (E2EE)</td></tr>
<tr><td>AI-generated image</td><td><code>memory_generated</code></td><td>Thumbnail</td><td>Full (E2EE)</td></tr>
</table>
<hr>
<h2>3.7 Database Engine Flexibility</h2>
<h3>3.7.1 The Database Question</h3>
<strong>Current Plan</strong>: PostgreSQL + pgvector
<strong>Challenge</strong>: PostgreSQL is heavy for a local Mac app. Can we support lighter alternatives?
<table>
<tr><th>Database</th><th>Pros</th><th>Cons</th><th>Best For</th></tr>
<tr><td><strong>PostgreSQL + pgvector</strong></td><td>Full-featured, proven, best vector search</td><td>Heavy (RAM), complex setup</td><td>Cloud, power users, servers</td></tr>
<tr><td><strong>SQLite + sqlite-vec</strong></td><td>Lightweight, single-file, portable</td><td>Limited concurrency, newer vector support</td><td>Local apps, single-user</td></tr>
<tr><td><strong>DuckDB</strong></td><td>Analytical queries, embedded</td><td>Less mature ecosystem</td><td>Analytics workloads</td></tr>
</table>
<h3>3.7.2 Recommended Architecture: Database Abstraction</h3>
<strong>Principle</strong>: Onelist Core should be database-agnostic where possible.
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                         DATABASE ABSTRACTION                                │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      Onelist Core (Elixir)                          │   │
│  │                                                                      │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐              │   │
│  │  │   Entries    │  │   Search     │  │    Sync      │              │   │
│  │  │   Context    │  │   Context    │  │   Context    │              │   │
│  │  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘              │   │
│  │         │                 │                 │                       │   │
│  │         └─────────────────┼─────────────────┘                       │   │
│  │                           │                                         │   │
│  │                    ┌──────▼───────┐                                 │   │
│  │                    │  Repo Layer  │  ← Ecto with adapters          │   │
│  │                    └──────┬───────┘                                 │   │
│  │                           │                                         │   │
│  │         ┌─────────────────┼─────────────────┐                       │   │
│  │         │                 │                 │                       │   │
│  │  ┌──────▼───────┐  ┌──────▼───────┐  ┌──────▼───────┐              │   │
│  │  │   Postgres   │  │   SQLite     │  │   (Future)   │              │   │
│  │  │   Adapter    │  │   Adapter    │  │   Adapter    │              │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3>3.7.3 SQLite Feasibility Analysis - HONEST ASSESSMENT</h3>
<strong>Can SQLite handle Onelist's needs?</strong>
<table>
<tr><th>Requirement</th><th>PostgreSQL</th><th>SQLite</th><th>Notes</th></tr>
<tr><td>Basic CRUD</td><td>✅</td><td>✅</td><td>Ecto supports both</td></tr>
<tr><td>Full-text search</td><td>✅ tsvector</td><td>✅ FTS5</td><td>Different syntax, same capability</td></tr>
<tr><td>Vector search</td><td>✅ pgvector</td><td>⚠️ <strong>LIMITED</strong></td><td>See critical analysis below</td></tr>
<tr><td>JSON queries</td><td>✅ JSONB</td><td>✅ JSON1</td><td>Slightly different syntax</td></tr>
<tr><td>Concurrent writes</td><td>✅ Excellent</td><td>⚠️ Limited</td><td>Single-writer, but fine for single-user</td></tr>
<tr><td>Embedded/portable</td><td>❌</td><td>✅</td><td>SQLite is a single file</td></tr>
<tr><td>Memory footprint</td><td>~100MB+</td><td>~10MB</td><td>SQLite much lighter</td></tr>
</table>
<h3>3.7.3.1 CRITICAL: SQLite Vector Search Limitations</h3>
<strong>Research Findings (January 2026):</strong>
<p>Based on research from <a href="https://github.com/asg017/sqlite-vec">sqlite-vec GitHub</a>, <a href="https://liveblocks.io/blog/whats-the-best-vector-database-for-building-ai-products">Liveblocks comparison</a>, and <a href="https://dev.to/jonbiz/implementing-a-rag-system-inside-an-rdbms-sqlite-and-postgres-with-sqlite-vec-pgvector-4d5h">DEV Community analysis</a>:</p>
<table>
<tr><th>Capability</th><th>pgvector</th><th>sqlite-vec</th><th>Impact</th></tr>
<tr><td><strong>Index Types</strong></td><td>HNSW, IVFFlat</td><td>❌ Brute-force only</td><td>sqlite-vec is O(n) for every search</td></tr>
<tr><td><strong>Maturity</strong></td><td>Production-ready</td><td>Pre-v1, "expect breaking changes"</td><td>Risk for production use</td></tr>
<tr><td><strong>Max Dimensions</strong></td><td>16,000+</td><td>Unclear (tested to 8)</td><td>May not support 1536-dim embeddings well</td></tr>
<tr><td><strong>Search Performance</strong></td><td>Sub-100ms at 1M vectors</td><td>Degrades linearly</td><td>Unusable at scale</td></tr>
<tr><td><strong>Recall Quality</strong></td><td>Excellent with HNSW</td><td>Good (exact) but slow</td><td>Tradeoff: exact but O(n)</td></tr>
</table>
<strong>The Core Problem:</strong>
<pre><code class="language-">sqlite-vec Search Complexity:
<li>10k vectors: ~50ms (acceptable)</li>
<li>100k vectors: ~500ms (slow but usable)</li>
<li>1M vectors: ~5 seconds (unusable)</li>
<p>pgvector with HNSW:
<li>10k vectors: ~5ms</li>
<li>100k vectors: ~10ms</li>
<li>1M vectors: ~20ms</li>
</code></pre></p>
<h3>3.7.3.2 Alternative: Vectorlite (SQLite + HNSW)</h3>
<a href="https://github.com/1yefuwang1/vectorlite">Vectorlite</a> is a SQLite extension that uses hnswlib for indexing:
<table>
<tr><th>Feature</th><th>Vectorlite</th><th>sqlite-vec</th></tr>
<tr><td>Index Type</td><td>HNSW</td><td>Brute-force</td></tr>
<tr><td>Performance</td><td>3-100x faster</td><td>Baseline</td></tr>
<tr><td>Maturity</td><td>Newer</td><td>Pre-v1</td></tr>
<tr><td>Recall</td><td>Approximate (configurable)</td><td>Exact</td></tr>
</table>
<strong>Vectorlite Example:</strong>
<pre><code class="language-sql">-- Create HNSW index
CREATE VIRTUAL TABLE embeddings USING vectorlite(
  embedding float[1536],
  hnsw(ef_construction=100, M=30)
);
<p>-- Search with configurable ef (accuracy/speed tradeoff)
SELECT rowid, distance
FROM embeddings
WHERE embedding MATCH vector('[0.1, 0.2, ...]')
AND ef = 50
LIMIT 10;
</code></pre></p>
<h3>3.7.3.3 Revised Recommendation: Tiered Strategy</h3>
<p>Given these limitations, we need a more nuanced approach:</p>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                    REVISED DATABASE STRATEGY                                │
│                                                                              │
│  Scale-Appropriate Choices:                                                 │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  &lt; 50k memories (Most Users)                                        │   │
│  │  ───────────────────────────────────────────────────────────────    │   │
│  │  SQLite + Vectorlite (HNSW)                                         │   │
│  │  • Single file, portable, lightweight                               │   │
│  │  • HNSW index provides good performance                             │   │
│  │  • Perfect for Mac app, local installs                              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  50k - 500k memories (Power Users)                                  │   │
│  │  ───────────────────────────────────────────────────────────────    │   │
│  │  Option A: SQLite + Vectorlite (still viable with tuning)           │   │
│  │  Option B: PostgreSQL + pgvector (recommended)                      │   │
│  │  • Better concurrent access for heavy use                           │   │
│  │  • More mature, better tooling                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  &gt; 500k memories (Heavy Users / Enterprise)                         │   │
│  │  ───────────────────────────────────────────────────────────────    │   │
│  │  PostgreSQL + pgvector (required)                                   │   │
│  │  • Or dedicated vector DB (Qdrant, Milvus) alongside                │   │
│  │  • Consider cloud-hosted PostgreSQL                                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3>3.7.3.4 Hybrid Architecture Option</h3>
<p>For maximum flexibility, consider separating concerns:</p>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                    HYBRID ARCHITECTURE                                      │
│                                                                              │
│  ┌──────────────────────┐     ┌──────────────────────┐                     │
│  │       SQLite         │     │   Vector Index       │                     │
│  │  (Structured Data)   │     │   (Embeddings)       │                     │
│  │                      │     │                      │                     │
│  │  • entries           │     │  Option A: Vectorlite│                     │
│  │  • representations   │     │  Option B: hnswlib   │                     │
│  │  • tags              │     │    (file-based)      │                     │
│  │  • metadata          │     │  Option C: LanceDB   │                     │
│  │  • FTS5 index        │     │                      │                     │
│  └──────────┬───────────┘     └──────────┬───────────┘                     │
│             │                            │                                  │
│             └────────────┬───────────────┘                                  │
│                          │                                                  │
│                 ┌────────▼────────┐                                         │
│                 │  Onelist Core   │                                         │
│                 │  (Coordinates)  │                                         │
│                 └─────────────────┘                                         │
│                                                                              │
│  Pros: Best tool for each job; upgrade vector index independently          │
│  Cons: More complexity; two data stores to sync/backup                     │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3>3.7.3.5 Practical Recommendation</h3>
<strong>For Mac App / Local Install:</strong>
1. <strong>Primary</strong>: SQLite + Vectorlite (HNSW)
2. <strong>Fallback</strong>: If Vectorlite issues, use sqlite-vec for small collections (<20k)
3. <strong>Upgrade path</strong>: Migrate to PostgreSQL when needed (export/import tool)
<strong>For Cloud / Server:</strong>
1. <strong>Always</strong>: PostgreSQL + pgvector
2. No reason to use SQLite on server
<strong>Implementation Priority:</strong>
1. Build with PostgreSQL first (proven, mature)
2. Add SQLite + Vectorlite adapter for Mac app
3. Benchmark both at realistic scales
4. Document upgrade path clearly
<strong>Recommendation</strong>: Support both, but be honest about limitations:
<pre><code class="language-elixir"># config/config.exs
config :onelist, Onelist.Repo,
  adapter: if System.get_env(&quot;ONELIST_DB&quot;) == &quot;postgres&quot;,
    do: Ecto.Adapters.Postgres,
    else: Ecto.Adapters.SQLite3
<h1>Vector search abstraction</h1>
defmodule Onelist.Search.Vector do
  @adapter Application.compile_env(:onelist, :vector_adapter, Onelist.Search.Vector.SQLiteVec)
<p>def search(query_embedding, opts) do
    @adapter.search(query_embedding, opts)
  end
end
</code></pre></p>
<h3>3.7.4 Alternative: Embedded PostgreSQL Everywhere</h3>
<strong>Key Discovery</strong>: PostgreSQL can be bundled and run as an embedded-like experience!
<h4>Available Options</h4>
<table>
<tr><th>Solution</th><th>How It Works</th><th>Size</th><th>pgvector</th></tr>
<tr><td><a href="https://postgresapp.com/">Postgres.app</a></td><td>macOS app, can extract binaries</td><td>~100-150MB (single version)</td><td>✅ Bundled</td></tr>
<tr><td><a href="https://github.com/theseus-rs/postgresql-embedded">postgresql-embedded (Rust)</a></td><td>Bundles PG in binary, runs as subprocess</td><td>~100-150MB</td><td>✅ Can include</td></tr>
<tr><td><a href="https://github.com/fergusstrange/embedded-postgres">embedded-postgres (Go)</a></td><td>Downloads/bundles PG, runs as subprocess</td><td>~100-150MB</td><td>✅ Can include</td></tr>
</table>
<strong>How It Works:</strong>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                    EMBEDDED POSTGRESQL ARCHITECTURE                         │
│                                                                              │
│  Onelist.app                                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Native Shell (SwiftUI)                                              │   │
│  │       │                                                              │   │
│  │       ▼                                                              │   │
│  │  ┌─────────────────────────────────────────────────────────────┐    │   │
│  │  │  Elixir Runtime (Burrito)                                   │    │   │
│  │  │       │                                                     │    │   │
│  │  │       ├── Onelist Core (Ecto)                               │    │   │
│  │  │       │                                                     │    │   │
│  │  │       └── PostgreSQL Manager                                │    │   │
│  │  │               │                                             │    │   │
│  │  │               ▼  spawn/manage                               │    │   │
│  │  └───────────────┼─────────────────────────────────────────────┘    │   │
│  │                  │                                                   │   │
│  │  ┌───────────────▼───────────────────────────────────────────────┐  │   │
│  │  │  PostgreSQL Process (bundled binaries)                        │  │   │
│  │  │  • postgresql binary (~50MB)                                  │  │   │
│  │  │  • pgvector.so extension                                      │  │   │
│  │  │  • Data dir: ~/Library/Application Support/Onelist/pg_data   │  │   │
│  │  │  • Listens on: localhost:5432 (or Unix socket)               │  │   │
│  │  └───────────────────────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  Total app size: ~150-200MB (Elixir + PostgreSQL + pgvector)               │
│  RAM usage: ~100-150MB (PostgreSQL process + Elixir)                       │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h4>Comparison: Embedded PostgreSQL vs SQLite+Vectorlite</h4>
<table>
<tr><th>Factor</th><th>Embedded PostgreSQL</th><th>SQLite + Vectorlite</th></tr>
<tr><td><strong>App Size</strong></td><td>~150-200MB</td><td>~20-30MB</td></tr>
<tr><td><strong>RAM Usage</strong></td><td>~100-150MB</td><td>~30-50MB</td></tr>
<tr><td><strong>Vector Search</strong></td><td>pgvector (HNSW, IVFFlat) - mature</td><td>Vectorlite (HNSW) - newer</td></tr>
<tr><td><strong>Code Paths</strong></td><td>Single codebase</td><td>Two adapters to maintain</td></tr>
<tr><td><strong>Startup Time</strong></td><td>~2-5 seconds (PG startup)</td><td>Instant</td></tr>
<tr><td><strong>Truly Embedded</strong></td><td>No (subprocess)</td><td>Yes (in-process)</td></tr>
<tr><td><strong>Backup</strong></td><td>pg_dump or copy data dir</td><td>Copy single file</td></tr>
<tr><td><strong>Max Scale</strong></td><td>Millions of vectors</td><td>~100k-500k vectors</td></tr>
<tr><td><strong>Concurrency</strong></td><td>Excellent</td><td>Limited (single writer)</td></tr>
<tr><td><strong>Production Proven</strong></td><td>✅ Decades</td><td>⚠️ Newer</td></tr>
</table>
<h4>REVISED RECOMMENDATION: PostgreSQL Everywhere</h4>
<p>Given the analysis, <strong>embedded PostgreSQL everywhere</strong> may be the better choice:</p>
<strong>Pros:</strong>
1. <strong>Single codebase</strong> - No SQLite adapter to maintain
2. <strong>pgvector is battle-tested</strong> - HNSW indexing, proven at scale
3. <strong>No compromises</strong> - Same capabilities local and cloud
4. <strong>Simpler testing</strong> - One database engine to test against
5. <strong>Familiar tooling</strong> - pg_dump, psql, etc. all work
<strong>Cons:</strong>
1. <strong>Larger app</strong> - ~150MB vs ~20MB (but modern Macs have plenty of storage)
2. <strong>More RAM</strong> - ~100MB (acceptable for desktop app)
3. <strong>Subprocess management</strong> - Need to handle PostgreSQL lifecycle
4. <strong>Startup time</strong> - Few seconds vs instant
<strong>For OpenClaw sidecar (minimal footprint):</strong>
<li>Could still use SQLite+Vectorlite for truly minimal installs</li>
<li>Or accept the PostgreSQL overhead (~150MB)</li>
<h3>3.7.5 Final Implementation Strategy</h3>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                    SIMPLIFIED: POSTGRESQL EVERYWHERE                        │
│                                                                              │
│  Cloud/Server:          Mac App:              OpenClaw Sidecar:             │
│  ┌─────────────┐        ┌─────────────┐       ┌─────────────┐              │
│  │ PostgreSQL  │        │ PostgreSQL  │       │ PostgreSQL  │              │
│  │ (managed)   │        │ (embedded)  │       │ (embedded)  │              │
│  │ + pgvector  │        │ + pgvector  │       │ + pgvector  │              │
│  │             │        │             │       │             │              │
│  │ Full Onelist│        │ Onelist.app │       │ File watcher│              │
│  │ + all       │        │ + selected  │       │ + search    │              │
│  │ daemons     │        │ agents      │       │ augment     │              │
│  └─────────────┘        └─────────────┘       └─────────────┘              │
│                                                                              │
│  Same Elixir code everywhere. Same Ecto queries. Same pgvector.            │
│  Only difference: who manages the PostgreSQL process.                       │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<strong>Implementation Steps:</strong>
<p>1. <strong>Build Onelist Core with PostgreSQL/pgvector</strong> (already the plan)
2. <strong>Create PostgreSQL bundling module</strong> for Mac app:
   <pre><code class="language-elixir">   defmodule Onelist.EmbeddedPostgres do
     def start do
       # Extract bundled PostgreSQL if needed
       # Initialize data directory if needed
       # Start PostgreSQL process
       # Wait for ready
       # Return connection config
     end</p>
<p>def stop do
       # Graceful shutdown
     end
   end
   </code></pre>
3. <strong>Bundle PostgreSQL binaries</strong> in Mac app release
4. <strong>Handle lifecycle</strong> - start on app launch, stop on quit
5. <strong>Manage data directory</strong> - ~/Library/Application Support/Onelist/</p>
<strong>Fallback Option:</strong>
If embedded PostgreSQL proves problematic, we can still add SQLite+Vectorlite as a lightweight alternative. But start with PostgreSQL-only to keep things simple.
<hr>
<h2>3.8 Mac App Architecture</h2>
<h3>3.8.1 Vision: Onelist.app for macOS</h3>
<p>A native Mac app that bundles Onelist Core + selected agents, optimized for local use.</p>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                           ONELIST.APP (macOS)                               │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        Native macOS Shell                            │   │
│  │                     (SwiftUI / AppKit wrapper)                       │   │
│  │                                                                      │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐              │   │
│  │  │  Menu Bar    │  │  Settings    │  │  Status      │              │   │
│  │  │  Icon        │  │  UI          │  │  Dashboard   │              │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    Embedded Elixir Runtime                          │   │
│  │                                                                      │   │
│  │  ┌──────────────────────────────────────────────────────────────┐  │   │
│  │  │                     Onelist Core                              │  │   │
│  │  │  • REST API (localhost:4000)                                  │  │   │
│  │  │  • SQLite + sqlite-vec                                        │  │   │
│  │  │  • Sync engine                                                │  │   │
│  │  │  • File watcher (for OpenClaw integration)                     │  │   │
│  │  └──────────────────────────────────────────────────────────────┘  │   │
│  │                                                                      │   │
│  │  ┌────────────┐  ┌────────────┐  ┌────────────┐  ┌────────────┐   │   │
│  │  │  Searcher  │  │   Reader   │  │   Writer   │  │ Researcher │   │   │
│  │  │   Daemon   │  │   Daemon   │  │   Daemon   │  │   Daemon   │   │   │
│  │  │ (optional) │  │ (optional) │  │ (optional) │  │ (optional) │   │   │
│  │  └────────────┘  └────────────┘  └────────────┘  └────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                         Local Storage                                │   │
│  │  ~/Library/Application Support/Onelist/                             │   │
│  │  ├── onelist.db          (SQLite database)                          │   │
│  │  ├── assets/             (thumbnails, cached media)                 │   │
│  │  └── config.json         (settings)                                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3>3.8.2 Mac App Onboarding Flow</h3>
<strong>DECIDED: First Launch Experience</strong>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                         ONELIST - WELCOME                                   │
│                                                                              │
│                              [Onelist Logo]                                  │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Email:    [_________________________________]                       │   │
│  │  Password: [_________________________________]                       │   │
│  │                                                                      │   │
│  │  [Sign In]                                                           │   │
│  │                                                                      │   │
│  │  Don't have an account? [Sign up →]  (opens browser)                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<strong>DECIDED: Post-Login Setup Flow</strong>
<pre><code class="language-">Step 1: Encryption Setup (REQUIRED)
──────────────────────────────────────────────────────────────────────────────
┌─────────────────────────────────────────────────────────────────────────────┐
│                    ENCRYPTION PASSPHRASE                                    │
│                                                                              │
│  Your data is encrypted end-to-end. Only you can read it.                  │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  ○ This is my first device                                          │   │
│  │    Create a new encryption passphrase                               │   │
│  │                                                                      │   │
│  │  ○ I have an existing passphrase                                    │   │
│  │    Enter it to access your encrypted data                           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  Passphrase: [_________________________________]                            │
│  Confirm:    [_________________________________]                            │
│                                                                              │
│  ⚠️  If you lose this passphrase, your data cannot be recovered.           │
│                                                                              │
│  [Continue]                                                                  │
└─────────────────────────────────────────────────────────────────────────────┘
<p>Step 2: Initial Sync (REQUIRED)
──────────────────────────────────────────────────────────────────────────────
┌─────────────────────────────────────────────────────────────────────────────┐
│                    SYNC YOUR DATA                                           │
│                                                                              │
│  Found 10,247 items in your cloud account.                                  │
│                                                                              │
│  How would you like to sync?                                                │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  ○ Wait for full sync (Recommended for first device)                │   │
│  │    All your data will be downloaded before you start.               │   │
│  │    You can use the app once sync completes.                         │   │
│  │                                                                      │   │
│  │  ○ Sync in background                                               │   │
│  │    Start using the app immediately.                                 │   │
│  │    Older data will appear as it downloads.                          │   │
│  │    ℹ️  Search results may be incomplete until sync finishes.        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  [Start Sync]                                                               │
└─────────────────────────────────────────────────────────────────────────────┘</p>
<p>Step 3: Agent Selection (OPTIONAL - can skip)
──────────────────────────────────────────────────────────────────────────────
┌─────────────────────────────────────────────────────────────────────────────┐
│                    CONFIGURE AGENTS                                         │
│                                                                              │
│  Agents run locally to enhance your experience.                             │
│  You can change these settings anytime.                                     │
│                                                                              │
│  ☑️  Searcher - Semantic search with embeddings                             │
│  ☐  Reader - Summarize and extract from content                             │
│  ☐  Writer - AI writing assistance                                          │
│  ☐  Researcher - Find related content from the web                          │
│                                                                              │
│  [Continue]  [Skip for now →]                                               │
└─────────────────────────────────────────────────────────────────────────────┘</p>
<p>Step 4: OpenClaw Integration (OPTIONAL - can skip)
──────────────────────────────────────────────────────────────────────────────
┌─────────────────────────────────────────────────────────────────────────────┐
│                    OPENCLAW INTEGRATION                                      │
│                                                                              │
│  Connect to OpenClaw to sync your AI assistant's memory.                    │
│                                                                              │
│  OpenClaw memory directory:                                                  │
│  [~/openclaw/memory________________________] [Browse...]                     │
│                                                                              │
│  ☑️  Watch for new memories automatically                                   │
│  ☐  Import existing memories now                                            │
│                                                                              │
│  [Connect]  [Skip - I don't use OpenClaw →]                                 │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre></p>
<strong>DECIDED: Sync Progress Monitoring</strong>
<p>User chooses sync approach. Background sync is always monitorable:</p>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│  DASHBOARD                                                                  │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│  Sync Status:  ████████████░░░░░░░░  67%                                   │
│                6,865 of 10,247 items                                        │
│                ~4 minutes remaining                                         │
│                                                                              │
│  ⚠️  Search results may be incomplete until sync finishes.                  │
│                                                                              │
│  [View Details]                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
<p>┌─────────────────────────────────────────────────────────────────────────────┐
│  SYNC DETAILS                                                               │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│  Entries:      ████████████████████  100%  (8,421 / 8,421)                 │
│  Embeddings:   ████████████░░░░░░░░   62%  (5,221 / 8,421)                 │
│  Assets:       ████░░░░░░░░░░░░░░░░   23%  (421 / 1,826)                   │
│                                                                              │
│  Download rate: 2.4 MB/s                                                    │
│  Total size: ~850 MB remaining                                              │
│                                                                              │
│  [Pause Sync]  [Cancel]                                                     │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre></p>
<h3>3.8.3 Sync Status & Management UI</h3>
<strong>DECIDED: Sync UI Location</strong>
<li>[x] Menu bar icon with quick-glance dropdown (always visible)</li>
<li>[x] Full dashboard in main app window</li>
<li>[x] Full detail also available in web app (for VM tier users)</li>
<strong>Menu Bar Quick Glance:</strong>
<pre><code class="language-">┌──────────────────────────────────────┐
│  ☁️▼                                  │  ← Menu bar icon (changes based on status)
└──────────────────────────────────────┘
         │
         ▼
┌──────────────────────────────────────┐
│  Onelist                             │
│  ─────────────────────────────────── │
│  ✓ Synced                            │
│  Last sync: 2 minutes ago            │
│                                      │
│  Storage: 2.4 GB of ∞                │
│  Assets:  12.1 GB (Standard tier)    │
│                                      │
│  ─────────────────────────────────── │
│  [Open Onelist]  [Sync Now]          │
└──────────────────────────────────────┘
<p>┌──────────────────────────────────────┐  ← When syncing
│  Onelist                             │
│  ─────────────────────────────────── │
│  ↻ Syncing...                        │
│  ████████░░░░░░░░  52%               │
│  1,247 items remaining               │
│                                      │
│  ─────────────────────────────────── │
│  [Open Onelist]  [Pause]             │
└──────────────────────────────────────┘</p>
<p>┌──────────────────────────────────────┐  ← When error
│  Onelist                             │
│  ─────────────────────────────────── │
│  ⚠️ Sync Error                        │
│  Could not connect to cloud          │
│  Last successful: 3 hours ago        │
│                                      │
│  ─────────────────────────────────── │
│  [Open Onelist]  [Retry]             │
└──────────────────────────────────────┘
</code></pre></p>
<strong>Menu Bar Icon States:</strong>
<li>☁️ Synced (normal)</li>
<li>↻ Syncing (animated)</li>
<li>⚠️ Error (yellow/orange)</li>
<li>⏸ Paused (gray)</li>
<li>📴 Offline (gray, no connection)</li>
<strong>Full Dashboard (in-app):</strong>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│  SYNC &amp; STORAGE                                                             │
│  ─────────────────────────────────────────────────────────────────────────  │
│                                                                              │
│  SYNC STATUS                                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Status: ✓ Synced                                                   │   │
│  │  Last sync: January 28, 2026 at 3:45 PM                             │   │
│  │                                                                      │   │
│  │  Local items:     10,247                                            │   │
│  │  Cloud items:     10,247                                            │   │
│  │  Pending upload:  0                                                 │   │
│  │  Pending download: 0                                                │   │
│  │                                                                      │   │
│  │  [Sync Now]  [View Sync History]                                    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  STORAGE USAGE                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Entries &amp; Metadata                                                 │   │
│  │  ████████████░░░░░░░░░░░░░░░░░░  2.4 GB                            │   │
│  │                                                                      │   │
│  │  Assets (Standard tier - R2 only)                                   │   │
│  │  ████████████████░░░░░░░░░░░░░░  12.1 GB                           │   │
│  │                                                                      │   │
│  │  Bandwidth this month                                               │   │
│  │  ████░░░░░░░░░░░░░░░░░░░░░░░░░░  3.2 GB                            │   │
│  │                                                                      │   │
│  │  Estimated cost this month: $4.27                                   │   │
│  │                                                                      │   │
│  │  [Upgrade to Redundant Storage →]  (opens browser)                  │   │
│  │  [Manage Billing →]  (opens browser)                                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  SYNC HISTORY                                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Today                                                               │   │
│  │  • 3:45 PM  ✓ Synced 12 items (upload)                              │   │
│  │  • 2:30 PM  ✓ Synced 3 items (download from other device)           │   │
│  │  • 11:00 AM ✓ Full sync completed                                   │   │
│  │                                                                      │   │
│  │  Yesterday                                                           │   │
│  │  • 6:15 PM  ⚠️ Sync failed - retried successfully                    │   │
│  │  • 4:00 PM  ✓ Synced 45 items                                       │   │
│  │                                                                      │   │
│  │  [Load more...]                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<strong>DECIDED: Storage Upgrade Flow</strong>
<li>[x] "Upgrade" and "Manage Billing" buttons open browser to billing portal</li>
<li>[x] Consistent with signup flow (all billing via web + Stripe)</li>
<h3>3.8.4 Agent Selection in Mac App</h3>
<p>Users can enable/disable agents based on their needs:</p>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                    ONELIST.APP SETTINGS → AGENTS                            │
│                                                                              │
│  Core Services (always running):                                            │
│  ✅ Onelist Core API                                                        │
│  ✅ Sync Engine                                                             │
│  ✅ File Watcher (OpenClaw integration)                                      │
│                                                                              │
│  Optional Agents:                                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ ☑️ Searcher Daemon                                                   │   │
│  │    Auto-generate embeddings for new content                         │   │
│  │    LLM: [Ollama local ▼]  Model: [nomic-embed-text ▼]              │   │
│  │                                                                      │   │
│  │ ☑️ Reader Daemon                                                     │   │
│  │    Auto-summarize and compact memories                              │   │
│  │    LLM: [Claude API ▼]  Aggressiveness: [Low ▼]                    │   │
│  │                                                                      │   │
│  │ ☑️ Writer Daemon                                                     │   │
│  │    AI writing assistance                                            │   │
│  │    LLM: [Claude API ▼]                                              │   │
│  │                                                                      │   │
│  │ ☑️ Researcher Daemon                                                 │   │
│  │    Find related content from web                                    │   │
│  │    LLM: [Claude API ▼]  Auto-run: [On request only ▼]              │   │
│  │                                                                      │   │
│  │ ☐ Jarvis (Conversational)                                           │   │
│  │    Natural language interface to your memory                        │   │
│  │    (Requires: Searcher enabled)                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  LLM API Keys:                                                              │
│  • Anthropic: sk-ant-••••••••••••                                          │
│  • OpenAI: sk-••••••••••••                                                 │
│  • Ollama: http://localhost:11434 (detected ✓)                             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3>3.8.5 Multi-Instance Coordination</h3>
<strong>Scenario</strong>: User runs Onelist.app on Mac with Writer/Researcher agents, while OpenClaw runs on a home server with its own agents.
<pre><code class="language-">┌───────────────────────────────────────────────────────────────────────────┐
│                    MULTI-INSTANCE DEPLOYMENT                              │
│                                                                            │
│  ┌─────────────────────┐              ┌─────────────────────┐            │
│  │   MacBook Pro       │              │   Home Mac Mini     │            │
│  │                     │              │                     │            │
│  │  ┌───────────────┐  │              │  ┌───────────────┐  │            │
│  │  │ Onelist.app   │  │              │  │   OpenClaw     │  │            │
│  │  │               │  │              │  │   Instance    │  │            │
│  │  │ • Core API    │  │              │  │               │  │            │
│  │  │ • SQLite DB   │  │              │  │ ┌───────────┐ │  │            │
│  │  │ • Writer      │  │              │  │ │ Onelist   │ │  │            │
│  │  │ • Researcher  │  │              │  │ │ Sidecar   │ │  │            │
│  │  │               │  │              │  │ │           │ │  │            │
│  │  │ (no OpenClaw)  │  │              │  │ │ • Core    │ │  │            │
│  │  └───────┬───────┘  │              │  │ │ • SQLite  │ │  │            │
│  │          │          │              │  │ │ • Searcher│ │  │            │
│  └──────────┼──────────┘              │  │ │ • Reader  │ │  │            │
│             │                         │  │ └───────────┘ │  │            │
│             │                         │  └───────┬───────┘  │            │
│             │                         └──────────┼──────────┘            │
│             │                                    │                        │
│             │         ┌──────────────────┐       │                        │
│             └────────►│  Onelist Cloud   │◄──────┘                        │
│                       │  (E2EE Sync)     │                                │
│                       │                  │                                │
│                       │ • Encrypted      │                                │
│                       │   storage        │                                │
│                       │ • Sync coord     │                                │
│                       │ • Conflict       │                                │
│                       │   resolution     │                                │
│                       └──────────────────┘                                │
│                                                                            │
│  Both instances:                                                          │
│  • See same memories (synced via cloud)                                   │
│  • Run different agents (user choice)                                     │
│  • Can work offline (sync when connected)                                 │
│  • Share the same cloud account                                           │
└───────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h3>3.8.6 Agent Coordination Across Instances</h3>
<strong>Challenge</strong>: If Searcher runs on Mac Mini and Writer runs on MacBook, how do they coordinate?
<strong>Solution</strong>: Agents operate on local data; cloud syncs the results.
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                    AGENT COORDINATION VIA SYNC                             │
│                                                                              │
│  Mac Mini (Searcher):                 MacBook (Writer):                    │
│                                                                              │
│  1. New memory written               4. Sync pulls embedding               │
│  2. Searcher generates embedding     5. Writer can now use semantic search │
│  3. Embedding syncs to cloud            to find related content            │
│                                                                              │
│  Timeline:                                                                  │
│  ─────────────────────────────────────────────────────────────────────────  │
│  Mini: [write] → [embed] → [sync↑]                                         │
│  Cloud:                    [store] ─────────────────────────────────────→   │
│  MacBook:                           [sync↓] → [Writer uses embedding]       │
│                                                                              │
│  Latency: ~seconds (acceptable for non-real-time use cases)                │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<strong>Metadata for Coordination:</strong>
<pre><code class="language-elixir"># Each embedding/summary tracks which agent created it
%{
  &quot;created_by_agent&quot; =&gt; &quot;searcher&quot;,
  &quot;created_on_instance&quot; =&gt; &quot;mac-mini-home&quot;,
  &quot;created_at&quot; =&gt; &quot;2026-01-28T10:30:00Z&quot;,
  &quot;model_used&quot; =&gt; &quot;nomic-embed-text&quot;,
  &quot;model_version&quot; =&gt; &quot;1.5&quot;
}
</code></pre>
<h3>3.8.7 Implementation Approach for Mac App</h3>
<strong>Option A: Burrito (Elixir → Native Binary)</strong>
<li>Package Elixir app as standalone macOS binary</li>
<li>Wrap with minimal SwiftUI shell for menu bar / settings</li>
<li>Pros: Uses existing Elixir codebase</li>
<li>Cons: Large binary size (~50MB+)</li>
<strong>Option B: Desktop (Elixir + Native Shell)</strong>
<li>Similar to Burrito but more control over native integration</li>
<li>Can use <code>desktop</code> hex package</li>
<strong>Option C: Tauri + Elixir Backend</strong>
<li>Tauri for native UI (Rust-based, lighter than Electron)</li>
<li>Elixir backend runs as subprocess</li>
<li>Pros: Modern UI, good macOS integration</li>
<li>Cons: Two tech stacks</li>
<strong>Recommendation</strong>: Start with <strong>Option A (Burrito)</strong> for fastest path to working app, consider Tauri for v2 if better native integration needed.
<pre><code class="language-elixir"># mix.exs for Mac app build
defp releases do
  [
    onelist_mac: [
      include_executables_for: [:macos],
      steps: [:assemble, &amp;Burrito.wrap/1],
      burrito: [
        targets: [
          macos_arm64: [os: :darwin, cpu: :aarch64],
          macos_x86_64: [os: :darwin, cpu: :x86_64]
        ]
      ]
    ]
  ]
end
</code></pre>
<hr>
<h2>4. Schema Evolution</h2>
<h3>4.1 New Tables</h3>
<h4>4.1.1 <code>embeddings</code> Table</h4>
<pre><code class="language-sql">CREATE TABLE embeddings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  representation_id UUID NOT NULL REFERENCES representations(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  model_name VARCHAR(255) NOT NULL,
  model_version VARCHAR(100),
  dimensions INTEGER NOT NULL,
  vector vector(1536),  -- adjust based on model
  inserted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  metadata JSONB,
<p>CONSTRAINT unique_repr_model UNIQUE (representation_id, model_name)
);</p>
<p>CREATE INDEX embeddings_vector_idx ON embeddings
  USING ivfflat (vector vector_cosine_ops) WITH (lists = 100);
CREATE INDEX embeddings_user_id_idx ON embeddings(user_id);
CREATE INDEX embeddings_representation_id_idx ON embeddings(representation_id);
</code></pre></p>
<h4>4.1.2 <code>sync_state</code> Table (for cloud sync)</h4>
<pre><code class="language-sql">CREATE TABLE sync_state (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  entity_type VARCHAR(50) NOT NULL,  -- 'entry', 'representation', 'tag', etc.
  entity_id UUID NOT NULL,
  local_version INTEGER NOT NULL,
  cloud_version INTEGER,
  sync_status VARCHAR(20) NOT NULL DEFAULT 'pending',  -- 'pending', 'synced', 'conflict'
  last_synced_at TIMESTAMPTZ,
  encrypted_payload BYTEA,  -- for pending uploads
  inserted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
<p>CONSTRAINT unique_entity_sync UNIQUE (user_id, entity_type, entity_id)
);</p>
<p>CREATE INDEX sync_state_pending_idx ON sync_state(user_id, sync_status)
  WHERE sync_status = 'pending';
</code></pre></p>
<h4>4.1.3 <code>memory_access_log</code> Table (for relevance tracking)</h4>
<pre><code class="language-sql">CREATE TABLE memory_access_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  entry_id UUID NOT NULL REFERENCES entries(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  access_type VARCHAR(20) NOT NULL,  -- 'search_hit', 'direct_view', 'agent_recall'
  context JSONB,  -- what query led to this access, etc.
  inserted_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
<p>CREATE INDEX memory_access_log_entry_idx ON memory_access_log(entry_id);
CREATE INDEX memory_access_log_time_idx ON memory_access_log(inserted_at);</p>
<p>-- Materialized view for access counts (refresh periodically)
CREATE MATERIALIZED VIEW memory_access_stats AS
SELECT
  entry_id,
  COUNT(<em>) as access_count,
  MAX(inserted_at) as last_accessed_at
FROM memory_access_log
GROUP BY entry_id;
</code></pre></p>
<h3>4.2 Modifications to Existing Tables</h3>
<h4>4.2.1 <code>entries</code> Table Additions</h4>
<pre><code class="language-sql">ALTER TABLE entries ADD COLUMN memory_metadata JSONB DEFAULT '{}';
-- Contains: importance, decay_rate, pinned, source_agent, etc.
<p>ALTER TABLE entries ADD COLUMN expires_at TIMESTAMPTZ;
-- For memories with explicit expiration</p>
<p>ALTER TABLE entries ADD COLUMN archived_at TIMESTAMPTZ;
-- Soft archive for decayed memories
</code></pre></p>
<h4>4.2.2 <code>representations</code> Table Additions</h4>
<pre><code class="language-sql">ALTER TABLE representations ADD COLUMN is_summary BOOLEAN DEFAULT FALSE;
-- Marks representations that are AI-generated summaries
<p>ALTER TABLE representations ADD COLUMN summary_of_ids UUID[];
-- References to original representations this summarizes
</code></pre></p>
<h3>4.3 New Entry Types</h3>
<p>Add to validation/enum:
<li><code>memory_episode</code></li>
<li><code>memory_fact</code></li>
<li><code>memory_profile</code></li>
<li><code>memory_task</code></li>
<li><code>memory_observation</code></li>
<li><code>memory_summary</code> (for compacted memories)</li></p>
<h3>4.4 New Representation Types</h3>
<p>Add to validation/enum:
<li><code>embedding</code> (vector representation)</li>
<li><code>summary</code> (AI-generated summary)</li>
<li><code>structured_data</code> (JSON facts extracted from content)</li></p>
<hr>
<h2>5. API Design</h2>
<h3>5.1 Memory-Specific Endpoints</h3>
<h4>5.1.1 Core Memory Operations</h4>
<pre><code class="language-">POST   /api/v1/memory                    # Create memory
GET    /api/v1/memory/:id                # Get memory by ID
PUT    /api/v1/memory/:id                # Update memory
DELETE /api/v1/memory/:id                # Delete memory
GET    /api/v1/memory                    # List memories (paginated, filtered)
</code></pre>
<h4>5.1.2 Search Endpoints</h4>
<pre><code class="language-">POST   /api/v1/memory/search             # Hybrid search
POST   /api/v1/memory/search/semantic    # Vector-only search
POST   /api/v1/memory/search/keyword     # FTS-only search
GET    /api/v1/memory/recent             # Recent memories (agent daily log)
GET    /api/v1/memory/core               # Core facts (agent MEMORY.md)
</code></pre>
<h4>5.1.3 Memory Management</h4>
<pre><code class="language-">POST   /api/v1/memory/compact            # Trigger manual compaction
GET    /api/v1/memory/stats              # Usage statistics
POST   /api/v1/memory/bulk               # Bulk operations
POST   /api/v1/memory/export             # Export memories
POST   /api/v1/memory/import             # Import memories
</code></pre>
<h4>5.1.4 Sync Endpoints (for cloud coordination)</h4>
<pre><code class="language-">GET    /api/v1/sync/status               # Current sync status
POST   /api/v1/sync/push                 # Push local changes to cloud
POST   /api/v1/sync/pull                 # Pull cloud changes to local
GET    /api/v1/sync/conflicts            # List sync conflicts
POST   /api/v1/sync/resolve              # Resolve a conflict
DELETE /api/v1/sync/entry/:id            # Delete entry from cloud
</code></pre>
<h4>5.1.5 Headless Cloud API (Account, Billing, Devices)</h4>
<strong>DECIDED: Headless cloud needs these additional endpoints</strong>
<pre><code class="language-"># Authentication
POST   /api/v1/auth/login                # Get API token (email/password)
POST   /api/v1/auth/magic-link           # Request magic link email
POST   /api/v1/auth/magic-link/verify    # Verify magic link token
POST   /api/v1/auth/refresh              # Refresh API token
POST   /api/v1/auth/logout               # Invalidate token
<h1>Account Management</h1>
GET    /api/v1/account                   # Get account info
PUT    /api/v1/account                   # Update account settings
DELETE /api/v1/account                   # Delete account (requires confirmation)
POST   /api/v1/account/change-passphrase # Change encryption passphrase
POST   /api/v1/account/recovery-key      # Generate new recovery key
<h1>Billing &amp; Usage</h1>
GET    /api/v1/usage                     # Current usage stats
GET    /api/v1/usage/history             # Historical usage by period
GET    /api/v1/billing/status            # Current plan, storage tier
GET    /api/v1/billing/portal-url        # Get Stripe Customer Portal URL
<h1>Device Management</h1>
GET    /api/v1/devices                   # List authorized devices
POST   /api/v1/devices/authorize         # Start device authorization (for QR flow)
GET    /api/v1/devices/authorize/:code   # Check authorization status (polling)
POST   /api/v1/devices/authorize/:code/confirm  # Confirm from existing device
DELETE /api/v1/devices/:id               # Revoke device authorization
PUT    /api/v1/devices/:id               # Rename device
</code></pre>
<strong>Note:</strong> Full web portal for account/billing/marketing planned separately.
See <code>roadmap/onelist_website_plan.md</code> for corporate website details.
<h3>5.2 Request/Response Formats</h3>
<h4>5.2.1 Create Memory Request</h4>
<pre><code class="language-json">{
  &quot;entry_type&quot;: &quot;memory_episode&quot;,
  &quot;title&quot;: &quot;Discussion about Q1 planning&quot;,
  &quot;content&quot;: &quot;Full markdown content here...&quot;,
  &quot;content_type&quot;: &quot;markdown&quot;,
  &quot;tags&quot;: [&quot;work&quot;, &quot;planning&quot;],
  &quot;metadata&quot;: {
    &quot;source_agent&quot;: &quot;openclaw&quot;,
    &quot;session_id&quot;: &quot;abc123&quot;,
    &quot;importance&quot;: &quot;medium&quot;
  },
  &quot;generate_embedding&quot;: true,
  &quot;embedding_model&quot;: &quot;text-embedding-3-small&quot;
}
</code></pre>
<h4>5.2.2 Search Response</h4>
<pre><code class="language-json">{
  &quot;results&quot;: [
    {
      &quot;id&quot;: &quot;uuid&quot;,
      &quot;entry_type&quot;: &quot;memory_fact&quot;,
      &quot;title&quot;: &quot;User prefers dark mode&quot;,
      &quot;score&quot;: 0.92,
      &quot;score_breakdown&quot;: {
        &quot;semantic&quot;: 0.95,
        &quot;keyword&quot;: 0.85
      },
      &quot;snippet&quot;: &quot;...highlighted matching text...&quot;,
      &quot;metadata&quot;: {...},
      &quot;created_at&quot;: &quot;2026-01-15T10:30:00Z&quot;
    }
  ],
  &quot;total&quot;: 42,
  &quot;search_metadata&quot;: {
    &quot;query_embedding_time_ms&quot;: 45,
    &quot;search_time_ms&quot;: 12,
    &quot;model_used&quot;: &quot;text-embedding-3-small&quot;
  }
}
</code></pre>
<h3>5.3 API Versioning Strategy</h3>
<li>URL versioning: <code>/api/v1/</code>, <code>/api/v2/</code></li>
<li>Deprecation policy: 6 months notice before breaking changes</li>
<li>Feature flags for experimental endpoints</li>
<hr>
<h2>6. OpenClaw Compatibility</h2>
<h3>6.0 Primary Goal: Transparent Drop-In Replacement</h3>
<strong>GOAL</strong>: Make Onelist so painless to adopt that OpenClaw users get better memory <strong>without OpenClaw needing to change</strong>.
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                           BEFORE (OpenClaw Native)                           │
│                                                                              │
│  ┌──────────┐     memory_write()      ┌──────────────────┐                  │
│  │ OpenClaw  │ ──────────────────────→ │ memory/</em>.md files │                  │
│  │          │ ←────────────────────── │ (flat files)      │                  │
│  └──────────┘     memory_search()     └──────────────────┘                  │
│                                                                              │
│  Problems: No real DB, basic search, no sync, token bloat, fragile          │
└─────────────────────────────────────────────────────────────────────────────┘
<p>▼</p>
<p>┌─────────────────────────────────────────────────────────────────────────────┐
│                        AFTER (Onelist Drop-In)                              │
│                                                                              │
│  ┌──────────┐                        ┌─────────────────────────────────────┐│
│  │ OpenClaw  │   (unchanged API)      │         Onelist Ecosystem          ││
│  │          │ ◄─────────────────────►│                                     ││
│  └──────────┘                        │  ┌─────────────┐                    ││
│       │                              │  │Onelist Skill│ ← Thin shim        ││
│       │ memory_write()               │  │  (proxy)    │                    ││
│       │ memory_search()              │  └──────┬──────┘                    ││
│       │                              │         │                           ││
│       │                              │         ▼                           ││
│       │                              │  ┌─────────────┐                    ││
│       │                              │  │Onelist Core │ ← Storage          ││
│       │                              │  │    API      │                    ││
│       │                              │  └──────┬──────┘                    ││
│       │                              │         │                           ││
│       │                              │    ┌────┴────┐                      ││
│       │                              │    ▼         ▼                      ││
│       │                              │ ┌──────┐ ┌──────┐                   ││
│       │                              │ │Search│ │Reader│ ← Augmentation   ││
│       │                              │ │Daemon│ │Daemon│   (transparent)  ││
│       │                              │ └──────┘ └──────┘                   ││
│       │                              └─────────────────────────────────────┘│
│                                                                              │
│  Benefits: Real DB, hybrid search, E2EE sync, compaction, no OpenClaw changes│
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre></p>
<h3>6.0.1 What "Painless" Means</h3>
<table>
<tr><th>Aspect</th><th>Requirement</th></tr>
<tr><td><strong>Installation</strong></td><td>Single command or config change in OpenClaw</td></tr>
<tr><td><strong>Zero Migration</strong></td><td>No import needed - Onelist watches existing files</td></tr>
<tr><td><strong>API Compatibility</strong></td><td>OpenClaw's existing <code>memory_<em></code> tools work unchanged</td></tr>
<tr><td><strong>Zero Config</strong></td><td>Works out of box; advanced features opt-in</td></tr>
<tr><td><strong>Transparent Augmentation</strong></td><td>Onelist daemons improve memory without OpenClaw knowing</td></tr>
<tr><td><strong>Transparent Failure</strong></td><td>If Onelist is down/removed, OpenClaw works exactly as before</td></tr>
</table>
<h3>6.0.1.1 CRITICAL: Transparent Failure/Rollback Architecture</h3>
<strong>DESIGN PRINCIPLE</strong>: Onelist is <strong>additive</strong>, not a <strong>replacement</strong>. OpenClaw's native file-based memory is ALWAYS the source of truth.
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                     SIDECAR ARCHITECTURE (Not Replacement)                  │
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │                         OPENCLAW (Unchanged)                          │   │
│  │                                                                      │   │
│  │   memory_write() ──────────────────────────────────► memory/</em>.md    │   │
│  │                                                          │          │   │
│  │   memory_search() ─────┐                                 │          │   │
│  │                        │                                 │          │   │
│  └────────────────────────┼─────────────────────────────────┼──────────┘   │
│                           │                                 │              │
│                           │ (1) Always searches             │ (2) Files   │
│                           │     files first                 │     always  │
│                           ▼                                 │     written │
│                    ┌──────────────┐                         │              │
│                    │ Native File  │                         │              │
│                    │   Search     │◄────────────────────────┘              │
│                    └──────┬───────┘                                        │
│                           │                                                │
│                           │ Results                                        │
│                           ▼                                                │
│  ┌──────────────────────────────────────────────────────────────────────┐ │
│  │                    ONELIST LAYER (Optional Sidecar)                  │ │
│  │                                                                      │ │
│  │   ┌─────────────┐      ┌─────────────┐      ┌─────────────┐        │ │
│  │   │ File Watcher│      │ Skill Shim  │      │   Daemons   │        │ │
│  │   │ (mirrors to │      │ (augments   │      │ (embeddings,│        │ │
│  │   │  database)  │      │  search)    │      │  compaction)│        │ │
│  │   └──────┬──────┘      └──────┬──────┘      └──────┬──────┘        │ │
│  │          │                    │                    │               │ │
│  │          └────────────────────┼────────────────────┘               │ │
│  │                               ▼                                    │ │
│  │                    ┌─────────────────────┐                         │ │
│  │                    │   Onelist Core DB   │                         │ │
│  │                    │   (PostgreSQL)      │                         │ │
│  │                    └─────────────────────┘                         │ │
│  │                                                                    │ │
│  │   IF ONELIST DOWN/REMOVED: Layer disappears, OpenClaw unaffected   │ │
│  └────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<strong>Guarantees:</strong>
<table>
<tr><th>Scenario</th><th>What Happens</th><th>User Impact</th></tr>
<tr><td>Onelist running normally</td><td>Files written + mirrored to DB; search augmented with semantic results</td><td>Best experience</td></tr>
<tr><td>Onelist daemon crashes</td><td>Files still written; search uses files only</td><td>Slightly degraded search</td></tr>
<tr><td>Onelist completely removed</td><td>Files still written; search uses files only</td><td>Back to native OpenClaw</td></tr>
<tr><td>User reinstalls Onelist</td><td>File watcher re-syncs all .md files to DB</td><td>Automatic recovery</td></tr>
<tr><td>OpenClaw updated</td><td>Files format unchanged; Onelist adapts or gracefully degrades</td><td>No data loss</td></tr>
</table>
<strong>Implementation Requirements:</strong>
<p>1. <strong>OpenClaw ALWAYS writes to files</strong> - Skill does NOT intercept writes
2. <strong>File watcher mirrors to DB</strong> - Onelist watches <code>memory/</code> directory, mirrors changes
3. <strong>Search is augmented, not replaced</strong> - Skill combines file search + DB search results
4. <strong>Files are source of truth</strong> - DB can be rebuilt from files at any time
5. <strong>Uninstall leaves no trace</strong> - Removing Onelist skill leaves OpenClaw exactly as before</p>
<h3>6.0.2 Transparent Augmentation Strategy</h3>
<p>Onelist provides value <strong>beyond</strong> what OpenClaw asks for:</p>
<table>
<tr><th>OpenClaw Does</th><th>Onelist Transparently Adds</th></tr>
<tr><td><code>memory_write(content)</code></td><td>→ Stores in DB + Searcher daemon auto-generates embeddings</td></tr>
<tr><td><code>memory_search(query)</code></td><td>→ Hybrid search (FTS + vector) even if OpenClaw only asked for keyword</td></tr>
<tr><td>Writes daily logs</td><td>→ Reader daemon auto-compacts old episodes into summaries</td></tr>
<tr><td>Nothing (passive)</td><td>→ Sync daemon pushes to cloud (E2EE) for backup/multi-device</td></tr>
</table>
<strong>Key Insight</strong>: OpenClaw doesn't need to know about embeddings, compaction, or sync. It just reads/writes. Onelist makes the memory better behind the scenes.
<h3>6.0.3 Integration Levels</h3>
<strong>Level 0: Config-Only (Minimal Change)</strong>
<li>User points OpenClaw's memory directory to Onelist-managed location</li>
<li>Onelist Skill watches for file changes, mirrors to DB</li>
<li>OpenClaw continues using files; Onelist syncs/indexes in background</li>
<strong>Level 1: Skill Installation (Recommended)</strong>
<li>User installs <code>openclaw-skill-onelist</code></li>
<li>Skill intercepts <code>memory_<em></code> tool calls, routes to Onelist API</li>
<li>OpenClaw code unchanged; just uses skill</li>
<li>Full benefits: hybrid search, embeddings, sync</li>
<strong>Level 2: Native Integration (Future)</strong>
<li>OpenClaw natively supports Onelist as memory backend</li>
<li>Requires OpenClaw code changes (upstream contribution)</li>
<li>Maximum efficiency; minimum overhead</li>
<h3>6.0.4 Value Proposition for OpenClaw Users</h3>
<table>
<tr><th>Pain Point (Current OpenClaw)</th><th>Onelist Solution</th></tr>
<tr><td>$11 for "Hi" (token bloat from full context)</td><td>Smart retrieval returns only relevant memories</td></tr>
<tr><td>Memory hangs from incomplete compaction</td><td>Reader daemon handles compaction reliably</td></tr>
<tr><td>No sync between devices</td><td>E2EE cloud sync built-in</td></tr>
<tr><td>Flat file fragility</td><td>PostgreSQL with proper backups</td></tr>
<tr><td>Basic keyword search only</td><td>Hybrid search (semantic + keyword)</td></tr>
<tr><td>Manual <code>MEMORY.md</code> maintenance</td><td>Auto-compaction to core facts</td></tr>
<tr><td>Security risks (exposed files)</td><td>Encrypted at rest, proper auth</td></tr>
</table>
<h3>6.0.5 Implementation Priority</h3>
<strong>Phase 1: Drop-In Skill (Minimum Viable Integration)</strong>
<li>[ ] OpenClaw skill that intercepts memory operations</li>
<li>[ ] API endpoints matching OpenClaw's mental model</li>
<li>[ ] Import tool for existing <code>memory/</em>.md</code> files</li>
<li>[ ] Works with zero OpenClaw code changes</li>
<strong>Phase 2: Transparent Augmentation</strong>
<li>[ ] Searcher daemon auto-embeds new memories</li>
<li>[ ] Hybrid search improves results (OpenClaw doesn't know)</li>
<li>[ ] Reader daemon auto-compacts (configurable aggressiveness)</li>
<strong>Phase 3: Advanced Features (Opt-In)</strong>
<li>[ ] E2EE cloud sync</li>
<li>[ ] Multi-device memory sharing</li>
<li>[ ] Memory analytics/insights</li>
<li>[ ] Custom compaction strategies</li>
<h3>6.1 OpenClaw's Current Memory Model</h3>
<p>Based on analysis, OpenClaw uses:
<li><strong>Daily logs</strong>: <code>memory/YYYY-MM-DD.md</code> files</li>
<li><strong>Long-term memory</strong>: <code>memory/MEMORY.md</code> file</li>
<li><strong>Tools</strong>: <code>memory_search</code>, <code>memory_write</code></li>
<li><strong>Hybrid search</strong>: Vector + BM25 in parallel</li></p>
<h3>6.2 Compatibility Approach</h3>
<h4>Option A: OpenClaw Skill (Recommended - "openclaw-skill-onelist")</h4>
<p>The skill acts as a thin shim that intercepts OpenClaw's memory operations and routes them to Onelist.</p>
<strong>Skill Architecture (Sidecar - Files Always Primary):</strong>
<pre><code class="language-">┌────────────────────────────────────────────────────────────────┐
│                    openclaw-skill-onelist                       │
│                                                                │
│  KEY PRINCIPLE: Files are ALWAYS written by OpenClaw natively   │
│  Skill only AUGMENTS search, never intercepts writes           │
│                                                                │
│  ┌──────────────┐    ┌──────────────┐                         │
│  │memory_search │    │ File Watcher │  (separate process)     │
│  │  augmenter   │    │   Service    │                         │
│  └──────┬───────┘    └──────┬───────┘                         │
│         │                   │                                  │
│         │ Merge results     │ Mirror changes                   │
│         ▼                   ▼                                  │
│  ┌────────────────────────────────────┐                        │
│  │         Onelist Client             │                        │
│  └────────────────────────────────────┘                        │
│                                                                │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │         Configuration                                    │  │
│  │  • ONELIST_URL=http://localhost:4000                    │  │
│  │  • MEMORY_DIR=~/openclaw/memory                          │  │
│  │  • FALLBACK_TO_FILES=true  (if Onelist unavailable)     │  │
│  └──────────────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────────────┘
</code></pre>
<strong>Skill Implementation (Sidecar Pattern):</strong>
<pre><code class="language-typescript">// openclaw-skill-onelist/index.ts
import { OnelistClient } from './client';
import { OpenClawNativeSearch } from './native-fallback';
<p>export const onelistMemory = {
  name: 'onelist-memory',
  version: '1.0.0',</p>
<p>config: {
    onelistUrl: process.env.ONELIST_URL || 'http://localhost:4000',
    apiKey: process.env.ONELIST_API_KEY,
    memoryDir: process.env.OPENCLAW_MEMORY_DIR || './memory',
    fallbackToFiles: true,  // ALWAYS true - files are source of truth
  },</p>
<p>tools: {
    // AUGMENTS OpenClaw's memory_search (does NOT replace)
    // OpenClaw's native file search runs first, then we enhance
    memory_search: async (query: string, options?: SearchOptions) =&gt; {
      // Step 1: ALWAYS get native file results first
      const nativeResults = await OpenClawNativeSearch.search(
        config.memoryDir,
        query,
        options
      );</p>
<p>// Step 2: TRY to get Onelist augmented results
      let augmentedResults = [];
      try {
        const client = new OnelistClient(config);
        const response = await client.search({
          query,
          search_type: 'hybrid',
          limit: options?.limit || 10,
        });
        augmentedResults = response.results;
      } catch (error) {
        // Onelist unavailable - that's OK, we have file results
        console.log('Onelist unavailable, using file search only');
      }</p>
<p>// Step 3: Merge and dedupe results
      // Native file results are authoritative; Onelist adds semantic matches
      return mergeResults(nativeResults, augmentedResults, {
        preferNative: true,      // Files win on conflicts
        addSemanticMatches: true // But include Onelist semantic finds
      });
    },</p>
<p>// NOTE: memory_write is NOT intercepted!
    // OpenClaw writes to files natively. File watcher mirrors to DB.
    // This ensures files are ALWAYS written, even if Onelist is down.</p>
<p>// memory_get_recent - ALWAYS reads from files, augments with DB metadata
    memory_get_recent: async (days: number = 1) =&gt; {
      // Read directly from files (source of truth)
      const fileContent = await readRecentFiles(config.memoryDir, days);</p>
<p>// Optionally augment with Onelist metadata (access counts, etc.)
      try {
        const client = new OnelistClient(config);
        return augmentWithMetadata(fileContent, client);
      } catch {
        return fileContent; // Files alone are fine
      }
    },</p>
<p>// memory_get_core - reads MEMORY.md directly, augments with DB
    memory_get_core: async () =&gt; {
      // Read MEMORY.md directly (source of truth)
      const memoryMd = await readFile(
        path.join(config.memoryDir, 'MEMORY.md')
      );</p>
<p>// Optionally augment with Onelist-generated summaries
      try {
        const client = new OnelistClient(config);
        const summaries = await client.listMemories({
          entry_types: ['memory_summary'],
          limit: 10,
        });
        return mergeCoreFacts(memoryMd, summaries);
      } catch {
        return memoryMd; // MEMORY.md alone is fine
      }
    },
  },</p>
<p>// File Watcher Service (runs as separate process)
  fileWatcher: {
    // Watches memory/<em>.md and mirrors changes to Onelist DB
    // This is ONE-WAY: files → DB (never DB → files)
    start: async () =&gt; {
      const watcher = chokidar.watch(config.memoryDir, {
        persistent: true,
        ignoreInitial: false, // Sync existing files on start
      });</p>
<p>watcher.on('add', (path) =&gt; mirrorToOnelist(path, 'create'));
      watcher.on('change', (path) =&gt; mirrorToOnelist(path, 'update'));
      watcher.on('unlink', (path) =&gt; mirrorToOnelist(path, 'delete'));
    },</p>
<p>// Mirror a file change to Onelist DB
    mirrorToOnelist: async (filePath: string, action: string) =&gt; {
      try {
        const client = new OnelistClient(config);
        const content = await readFile(filePath);
        const entryType = inferEntryType(filePath, content);</p>
<p>if (action === 'create' || action === 'update') {
          await client.upsertFromFile({
            file_path: filePath,  // Used as stable identifier
            content,
            entry_type: entryType,
            metadata: { source: 'openclaw_file', file_path: filePath }
          });
        } else if (action === 'delete') {
          await client.markDeleted({ file_path: filePath });
        }
      } catch (error) {
        // Mirror failed - that's OK, file is still there
        // Will retry on next change or periodic sync
        console.log(<code>Mirror to Onelist failed for ${filePath}, will retry</code>);
      }
    },
  },</p>
<p>// Lifecycle
  onInstall: async () =&gt; {
    console.log('Onelist Memory skill installed (sidecar mode)');
    console.log('Your memory/</em>.md files remain the source of truth');
    console.log('Onelist will watch and augment, never replace');
  },</p>
<p>onUninstall: async () =&gt; {
    console.log('Onelist Memory skill removed');
    console.log('Your memory/<em>.md files are unchanged');
    console.log('OpenClaw will continue working with native file search');
  },
};</p>
<p>// Merge native file results with Onelist semantic results
function mergeResults(native: Result[], augmented: Result[], opts): Result[] {
  const seen = new Set(native.map(r =&gt; r.id || r.filePath));</p>
<p>// Start with all native results
  const merged = [...native];</p>
<p>// Add semantic matches from Onelist that weren't in file search
  for (const result of augmented) {
    const fileKey = result.metadata?.file_path;
    if (fileKey &amp;&amp; !seen.has(fileKey)) {
      merged.push({
        ...result,
        source: 'onelist_semantic',  // Mark as semantic match
      });
      seen.add(fileKey);
    }
  }</p>
<p>return merged;
}
</code></pre></p>
<strong>Installation (One Command):</strong>
<pre><code class="language-bash"># In OpenClaw directory
openclaw skill install onelist-memory
<h1>That's it! No migration needed.</h1>
<h1>Onelist will:</h1>
<h1>1. Start watching your memory/</em>.md files</h1>
<h1>2. Mirror them to its database (for semantic search)</h1>
<h1>3. Augment your searches with semantic results</h1>
#
<h1>Your files are NEVER modified or moved.</h1>
<h1>Uninstall anytime - OpenClaw continues working exactly as before.</h1>
</code></pre>
<strong>What Happens on Uninstall:</strong>
<pre><code class="language-bash">openclaw skill uninstall onelist-memory
<h1>Result:</h1>
<h1>✓ Skill removed</h1>
<h1>✓ memory/<em>.md files: UNCHANGED (they were never touched)</h1>
<h1>✓ OpenClaw: Works exactly as before, using native file search</h1>
<h1>✓ Onelist DB: Can be deleted or kept (orphaned, doesn't matter)</h1>
</code></pre>
<h4>Option B: API Compatibility Layer</h4>
Expose OpenClaw-compatible endpoints that translate to Onelist operations.
<pre><code class="language-"># OpenClaw-compatible endpoints
POST /api/openclaw/memory/search     → POST /api/v1/memory/search
POST /api/openclaw/memory/write      → POST /api/v1/memory
GET  /api/openclaw/memory/daily      → GET /api/v1/memory?entry_type=memory_episode&amp;date=today
GET  /api/openclaw/memory/core       → GET /api/v1/memory?entry_type=memory_fact
</code></pre>
<h3>6.2.5 Transparent Augmentation Daemons</h3>
<p>These daemons run alongside Onelist Core and improve OpenClaw's memory <strong>without OpenClaw's involvement</strong>.</p>
<h4>Onelist Searcher Daemon (Auto-Embedding)</h4>
<strong>Purpose</strong>: Automatically generate embeddings for new memories so hybrid search works.
<pre><code class="language-">┌─────────────────────────────────────────────────────────────┐
│                   Onelist Searcher Daemon                   │
│                                                             │
│   1. Subscribe to webhook: &quot;memory.created&quot;                 │
│   2. For each new memory without embedding:                 │
│      a. Fetch content from Onelist API                      │
│      b. Generate embedding (local model or API)             │
│      c. Store embedding via Onelist API                     │
│   3. Repeat on schedule for any missed entries              │
│                                                             │
│   Config:                                                   │
│   • EMBEDDING_MODEL=text-embedding-3-small                  │
│   • EMBEDDING_PROVIDER=openai|ollama|local                  │
│   • BATCH_SIZE=100                                          │
│   • POLL_INTERVAL=60s (fallback if webhooks fail)          │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<strong>Why OpenClaw Benefits</strong>: Even though OpenClaw just writes plain text, searches become semantic because Searcher daemon added embeddings behind the scenes.
<h4>Onelist Reader Daemon (Auto-Compaction)</h4>
<strong>Purpose</strong>: Automatically summarize/compact old memories to prevent bloat.
<pre><code class="language-">┌─────────────────────────────────────────────────────────────┐
│                   Onelist Reader Daemon                     │
│                                                             │
│   Daily job:                                                │
│   1. Query memories older than N days (configurable)        │
│   2. Group episodes by day/week                             │
│   3. Generate summary using LLM                             │
│   4. Store summary as memory_summary entry                  │
│   5. Link summary to original entries                       │
│   6. Archive originals (still searchable, lower rank)       │
│                                                             │
│   Weekly job:                                               │
│   1. Find semantically similar facts                        │
│   2. Merge duplicates (LLM decides)                         │
│   3. Update memory_profile with patterns                    │
│                                                             │
│   Config:                                                   │
│   • COMPACT_AFTER_DAYS=7                                    │
│   • SUMMARIZATION_MODEL=claude-3-haiku                      │
│   • AGGRESSIVENESS=low|medium|high                          │
│   • DRY_RUN=false (preview changes first)                  │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<strong>Why OpenClaw Benefits</strong>: OpenClaw's context stays lean because old episodes are summarized. OpenClaw doesn't need to implement compaction logic itself.
<h4>Daemon Deployment Options</h4>
<strong>Option A: All-in-One (Simplest)</strong>
<pre><code class="language-bash"># Single Docker Compose with everything
docker-compose up -d onelist-core onelist-searcher onelist-reader
</code></pre>
<strong>Option B: Core Only (OpenClaw handles everything)</strong>
<pre><code class="language-bash"># Just storage - OpenClaw or user provides intelligence
docker-compose up -d onelist-core
</code></pre>
<strong>Option C: Selective Daemons</strong>
<pre><code class="language-bash"># Just embedding, no compaction (user prefers manual)
docker-compose up -d onelist-core onelist-searcher
</code></pre>
<h4>Value Add Summary</h4>
<table>
<tr><th>Without Daemons</th><th>With Daemons</th></tr>
<tr><td>OpenClaw must generate embeddings</td><td>Auto-embedded on write</td></tr>
<tr><td>OpenClaw must implement compaction</td><td>Auto-compacted daily</td></tr>
<tr><td>Search is FTS only (unless OpenClaw embeds)</td><td>Hybrid search always works</td></tr>
<tr><td>Memory grows unbounded</td><td>Summaries keep it lean</td></tr>
<tr><td>OpenClaw bears all LLM costs</td><td>Daemons can use cheaper models</td></tr>
</table>
<h3>6.2.6 User Experience: 5-Minute Setup (Zero Risk)</h3>
<strong>Goal</strong>: A OpenClaw user can add Onelist in under 5 minutes with <strong>zero risk to existing data</strong>.
<h4>Quick Start Guide (Draft)</h4>
<pre><code class="language-markdown"># Supercharge Your OpenClaw Memory in 5 Minutes
<h1>(Your files stay exactly where they are - zero risk!)</h1>
<h2>Step 1: Start Onelist (1 min)</h2>
<h1>Option A: Docker (recommended)</h1>
curl -fsSL https://onelist.com/install.sh | sh
<h1>This starts: Onelist Core + Searcher daemon + Reader daemon</h1>
<h1>Option B: Mac App (coming soon)</h1>
<h1>Download Onelist.app, drag to Applications, launch</h1>
<h2>Step 2: Install the OpenClaw Skill (1 min)</h2>
<p>cd ~/openclaw  # or wherever your OpenClaw is
openclaw skill install onelist-memory</p>
<h1>Point it at your memory directory</h1>
export OPENCLAW_MEMORY_DIR=~/openclaw/memory
<h2>Step 3: There is no Step 3!</h2>
<p>That's it. Onelist is now:
✓ Watching your memory/</em>.md files (read-only, never modifies them)
✓ Mirroring them to a database (for semantic search)
✓ Generating embeddings in the background
✓ Ready to augment your searches</p>
<p>Your files are UNTOUCHED. Uninstall anytime - nothing changes.</p>
<h2>What You Get:</h2>
<p>✓ Better search (semantic + keyword combined)
✓ Auto-compaction summaries (stored in Onelist DB, not your files)
✓ Cloud sync ready (when you want it)
✓ ZERO RISK to existing data - files are never modified</p>
<h2>Optional: Enable Cloud Sync</h2>
<p>onelist auth login  # Create account or sign in
onelist sync enable</p>
<p>Now your memories sync (encrypted) across all your devices.
Your local files remain the source of truth.
</code></pre></p>
<h4>What Happens Behind the Scenes</h4>
<pre><code class="language-">User runs: openclaw skill install onelist-memory
                    │
                    ▼
┌──────────────────────────────────────────────────────────────┐
│ Skill installs TWO components:                               │
│                                                              │
│ 1. Search Augmenter:                                         │
│    memory_search → native file search FIRST, then augment    │
│    with Onelist semantic matches                             │
│    (Files are always searched - Onelist adds extras)         │
│                                                              │
│ 2. File Watcher Service:                                     │
│    Watches memory/<em>.md → mirrors to Onelist DB               │
│    (ONE-WAY: files → DB, never DB → files)                   │
│                                                              │
│ IMPORTANT: memory_write is NOT intercepted!                  │
│ OpenClaw writes files exactly as it always did.               │
└──────────────────────────────────────────────────────────────┘
                    │
                    ▼
┌──────────────────────────────────────────────────────────────┐
│ File Watcher does initial sync:                              │
│                                                              │
│   Scanning memory/</em>.md...                                    │
│   ✓ Found 247 daily logs → mirroring to DB (files unchanged) │
│   ✓ Found MEMORY.md → mirroring to DB (file unchanged)       │
│   ✓ Searcher daemon generating embeddings... (background)    │
│                                                              │
│   Original files: COMPLETELY UNCHANGED                       │
│   Onelist DB: Now has searchable copy with embeddings        │
└──────────────────────────────────────────────────────────────┘
                    │
                    ▼
OpenClaw continues writing files exactly as before.
Searches now return native results + semantic matches.
If Onelist stops, OpenClaw keeps working with files alone.
</code></pre>
<h4>First Search Experience</h4>
<pre><code class="language-">User: &quot;What did we discuss about the project deadline?&quot;
<p>OPENCLAW NATIVE SEARCH (always runs first):
<li>Searches memory/<em>.md files directly</li>
<li>Finds: &quot;project deadline mentioned in 2026-01-15.md&quot;</li>
<li>This ALWAYS works, even if Onelist is down</li></p>
<p>ONELIST AUGMENTATION (adds semantic matches):
<li>Searches embeddings in its database</li>
<li>Finds: &quot;delivery date&quot; in 2026-01-10.md (semantic match!)</li>
<li>Finds: &quot;Q1 milestone&quot; in 2026-01-08.md (semantic match!)</li></p>
<p>MERGED RESULTS (best of both):
1. [FILE] project deadline - 2026-01-15.md (native match)
2. [SEMANTIC] delivery date - 2026-01-10.md  ← Onelist found this!
3. [SEMANTIC] Q1 milestone - 2026-01-08.md   ← Onelist found this!</p>
<p>If Onelist is down: User just gets result #1 (still useful!)
</code></pre></p>
<h4>Failure & Recovery Scenarios</h4>
<pre><code class="language-">SCENARIO A: Onelist crashes mid-session
─────────────────────────────────────────
What happens:
• OpenClaw continues writing to files (unchanged behavior)
• File watcher stops mirroring (but files are safe)
• Search augmentation fails gracefully → returns file results only
• User sees slightly degraded search (keyword only, no semantic)
• NO DATA LOSS - files are always written first
<p>Recovery:
• Restart Onelist
• File watcher re-syncs any files changed while down
• Back to full semantic search</p>
<p>SCENARIO B: User uninstalls Onelist completely
─────────────────────────────────────────────
What happens:
• Skill removed from OpenClaw
• File watcher stops
• OpenClaw reverts to native file-only search
• All memory/</em>.md files: EXACTLY as they were before Onelist
• Onelist DB: Orphaned (can be deleted, no impact)</p>
<p>User experience:
• &quot;It's like Onelist was never installed&quot;
• Search is less smart, but all data intact</p>
<p>SCENARIO C: Onelist DB corrupted
────────────────────────────────
What happens:
• Search augmentation returns errors → graceful fallback to files
• File watcher can rebuild entire DB from files
• Run: onelist rebuild --from-files</p>
<p>Recovery:
• Files are source of truth - DB is always rebuildable
• Zero data loss possible</p>
<p>SCENARIO D: User switches to different memory system
────────────────────────────────────────────────────
What happens:
• Files are portable - standard markdown
• Can import to Obsidian, Notion, anything that reads .md
• Onelist was just an enhancement layer, not a lock-in
</code></pre></p>
<h3>6.3 Migration Path (Actually: No Migration Needed!)</h3>
<p>With the sidecar architecture, there's <strong>no migration step</strong>. The file watcher handles everything:</p>
<pre><code class="language-">TRADITIONAL MIGRATION (what we're NOT doing):
─────────────────────────────────────────────
1. Export from old system
2. Transform data
3. Import to new system
4. Verify
5. Delete old data  ← SCARY!
<p>ONELIST SIDECAR APPROACH (what we ARE doing):
─────────────────────────────────────────────
1. Install skill
2. File watcher syncs existing files to DB automatically
3. Done! Files unchanged, DB populated
4. Uninstall anytime - files still there
</code></pre></p>
<strong>What the file watcher does on first run:</strong>
<pre><code class="language-elixir"># This runs automatically when skill is installed
defmodule Onelist.FileWatcher do
  def initial_sync(memory_dir) do
    # Find all .md files
    memory_dir
    |&gt; Path.join(&quot;<strong>/<em>.md&quot;)
    |&gt; Path.wildcard()
    |&gt; Enum.each(fn file_path -&gt;
      content = File.read!(file_path)
      entry_type = infer_type(file_path, content)
<p># Mirror to Onelist DB (file unchanged)
      Onelist.API.upsert_from_file(%{
        file_path: file_path,      # Stable identifier
        content: content,
        entry_type: entry_type,
        metadata: %{source: &quot;openclaw_file&quot;}
      })</p>
<p># Searcher daemon will auto-embed in background
    end)
  end</p>
<p>defp infer_type(path, content) do
    cond do
      String.ends_with?(path, &quot;MEMORY.md&quot;) -&gt; &quot;memory_fact&quot;
      Regex.match?(~r/\d{4}-\d{2}-\d{2}\.md$/, path) -&gt; &quot;memory_episode&quot;
      true -&gt; &quot;memory_episode&quot;
    end
  end
end
</code></pre></p>
</strong>If user wants explicit control:<strong>
<pre><code class="language-bash"># Optional: Run sync manually with progress
onelist sync ~/openclaw/memory/ --verbose
<h1>Syncing memory/</em>.md to Onelist DB...</h1>
<h1>✓ 2026-01-28.md → memory_episode (unchanged)</h1>
<h1>✓ 2026-01-27.md → memory_episode (unchanged)</h1>
<h1>✓ MEMORY.md → memory_fact (unchanged)</h1>
<h1>...</h1>
<h1>✓ Synced 247 files</h1>
<h1>✓ Generating embeddings... (background, ~2 min)</h1>
#
<h1>Your files were NOT modified. Onelist DB now has copies.</h1>
</code></pre>
<hr>
<h2>7. Sync Protocol</h2>
<h3>7.1 Design Goals</h3>
<li>Eventually consistent (not real-time)</li>
<li>Works offline; syncs when connectivity available</li>
<li>Handles multi-client conflicts gracefully</li>
<li>Efficient (delta sync, not full replication)</li>
<li>E2EE (cloud never sees plaintext)</li>
<h3>7.2 Sync Model</h3>
<h4>7.2.1 Vector Clocks</h4>
Each entity (entry, representation) carries a vector clock:
<pre><code class="language-json">{
  &quot;vector_clock&quot;: {
    &quot;client_a_uuid&quot;: 5,
    &quot;client_b_uuid&quot;: 3,
    &quot;cloud&quot;: 4
  }
}
</code></pre>
<h4>7.2.2 Sync Flow</h4>
</strong>Push (Local → Cloud):<strong>
1. Local detects change (via Ecto hooks or polling)
2. Encrypt payload with user's key
3. Include vector clock in metadata (unencrypted for conflict detection)
4. Upload to cloud
5. Cloud stores encrypted blob, updates coordination state
</strong>Pull (Cloud → Local):<strong>
1. Local queries cloud for changes since last sync
2. Cloud returns encrypted payloads + vector clocks
3. Local decrypts payloads
4. Detect conflicts via vector clock comparison
5. Apply non-conflicting changes; queue conflicts for resolution
<h3>7.3 Conflict Resolution</h3>
<table>
<tr><th>Scenario</th><th>Resolution</th></tr>
<tr><td>Same entry modified on two clients</td><td>Keep both versions; mark as conflict; user resolves</td></tr>
<tr><td>Entry deleted on one client, modified on another</td><td>Prefer modification (safer); notify user</td></tr>
<tr><td>Concurrent tag additions</td><td>Merge (union of tags)</td></tr>
<tr><td>Embedding regenerated with different model</td><td>Keep both embeddings</td></tr>
</table>
<h3>7.3.1 Multi-OpenClaw Scenario: New Instance Joining Existing Memories</h3>
</strong>Scenario<strong>: User has Onelist with 10k memories (from Mac app, web, or another OpenClaw). They set up a new OpenClaw instance on a different machine. How does it get access to existing memories?
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│              NEW OPENCLAW INSTANCE JOINING EXISTING MEMORIES                 │
│                                                                              │
│  BEFORE: User has memories in cloud from Instance A                         │
│                                                                              │
│  ┌─────────────────────┐              ┌─────────────────────┐               │
│  │   Instance A        │              │   Onelist Cloud     │               │
│  │   (Mac App)         │   synced     │                     │               │
│  │                     │ ──────────►  │   10,000 memories   │               │
│  │   10k memories      │              │   (encrypted)       │               │
│  └─────────────────────┘              └─────────────────────┘               │
│                                                                              │
│  AFTER: New OpenClaw instance joins                                          │
│                                                                              │
│  ┌─────────────────────┐              ┌─────────────────────┐               │
│  │   Instance A        │              │   Onelist Cloud     │               │
│  │   (Mac App)         │◄────────────►│                     │               │
│  │   10k memories      │              │   10,000 memories   │               │
│  └─────────────────────┘              └──────────┬──────────┘               │
│                                                  │                          │
│                                                  │ sync down                │
│                                                  ▼                          │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │   Instance B (NEW OpenClaw)                                          │   │
│  │                                                                      │   │
│  │   ┌─────────────────┐    ┌─────────────────┐                        │   │
│  │   │  Local Files    │    │  Local Database │                        │   │
│  │   │  (OpenClaw's)    │    │  (Onelist's)    │                        │   │
│  │   │                 │    │                 │                        │   │
│  │   │  EMPTY on start │    │  10k memories   │◄── synced from cloud   │   │
│  │   │  (no history)   │    │  (full history) │                        │   │
│  │   └────────┬────────┘    └────────┬────────┘                        │   │
│  │            │                      │                                  │   │
│  │            │    ┌─────────────────┘                                  │   │
│  │            │    │                                                    │   │
│  │            ▼    ▼                                                    │   │
│  │   ┌─────────────────────────────────────────┐                       │   │
│  │   │         Search Results                  │                       │   │
│  │   │                                         │                       │   │
│  │   │  Native file search: 0 results          │                       │   │
│  │   │  + Onelist augmentation: 10k results    │                       │   │
│  │   │  = User sees all memories!              │                       │   │
│  │   └─────────────────────────────────────────┘                       │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
</strong>Key Insight<strong>: The local files only contain what THIS OpenClaw instance wrote. The local database contains ALL memories (local + synced). Search returns results from the database, so the user sees everything.
</strong>Setup Flow for New Instance:<strong>
<pre><code class="language-">Step 1: User installs OpenClaw + Onelist sidecar on new machine
        └─► Onelist starts with empty local DB
<p>Step 2: User logs into Onelist cloud account
        └─► onelist auth login</p>
<p>Step 3: Onelist syncs down existing memories
        └─► Cloud → Local DB (decrypted)
        └─► This may take a few minutes for large collections
        └─► Progress: &quot;Syncing 10,000 memories... 45%&quot;</p>
<p>Step 4: OpenClaw is ready to use
        └─► Local files: empty (OpenClaw hasn't written anything yet)
        └─► Local DB: 10k memories (synced from cloud)
        └─► Search works immediately (returns DB results)</p>
<p>Step 5: OpenClaw writes new memories
        └─► New memory → local file → Onelist mirrors to DB → syncs to cloud
        └─► Other instances receive new memory via cloud sync
</code></pre></p>
</strong>What the User Experiences:<strong>
<pre><code class="language-">New OpenClaw instance, first interaction:
<p>User: &quot;What did we discuss about the project deadline?&quot;</p>
<p>OpenClaw searches via Onelist skill:
├─ Native file search: 0 results (files are empty)
└─ Onelist DB search: 5 results (from synced memories)</p>
<p>User sees: 5 relevant memories from their history
User thinks: &quot;Great, it has all my memories!&quot;</p>
<hr>
<p>User has conversation, OpenClaw writes memory:</p>
<p>OpenClaw: memory_write(&quot;User prefers morning meetings&quot;)
├─ Written to: ~/openclaw/memory/2026-01-28.md
├─ Onelist mirrors to local DB
└─ Onelist syncs to cloud</p>
<p>Other instances receive this memory within seconds/minutes.
</code></pre></p>
<h3>7.3.2 Multi-OpenClaw Scenario: Multiple Instances Writing Simultaneously</h3>
</strong>Scenario<strong>: User has OpenClaw at home AND at work. Both are actively used and writing memories. How do they stay in sync?
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│              MULTIPLE OPENCLAWS WRITING SIMULTANEOUSLY                       │
│                                                                              │
│  10:00 AM                                                                   │
│  ┌─────────────────────┐                      ┌─────────────────────┐      │
│  │   Home OpenClaw      │                      │   Work OpenClaw      │      │
│  │                     │                      │                     │      │
│  │   User: &quot;Remember   │                      │   User: &quot;Note that  │      │
│  │   to buy milk&quot;      │                      │   meeting moved     │      │
│  │                     │                      │   to 3pm&quot;           │      │
│  │   writes to:        │                      │   writes to:        │      │
│  │   memory/2026-01-28 │                      │   memory/2026-01-28 │      │
│  │   .md               │                      │   .md               │      │
│  └──────────┬──────────┘                      └──────────┬──────────┘      │
│             │                                            │                  │
│             │ mirror to DB                               │ mirror to DB    │
│             ▼                                            ▼                  │
│  ┌─────────────────────┐                      ┌─────────────────────┐      │
│  │   Home Onelist DB   │                      │   Work Onelist DB   │      │
│  │                     │                      │                     │      │
│  │   memory_abc123     │                      │   memory_def456     │      │
│  │   &quot;buy milk&quot;        │                      │   &quot;meeting 3pm&quot;     │      │
│  │   instance: home    │                      │   instance: work    │      │
│  │   time: 10:00:01    │                      │   time: 10:00:03    │      │
│  └──────────┬──────────┘                      └──────────┬──────────┘      │
│             │                                            │                  │
│             │ sync to cloud                              │ sync to cloud   │
│             ▼                                            ▼                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        Onelist Cloud                                │   │
│  │                                                                      │   │
│  │   Receives both memories - NO CONFLICT (different IDs)              │   │
│  │                                                                      │   │
│  │   memory_abc123 (from home): &quot;buy milk&quot;                             │   │
│  │   memory_def456 (from work): &quot;meeting 3pm&quot;                          │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│             │                                            │                  │
│             │ sync down                                  │ sync down       │
│             ▼                                            ▼                  │
│  ┌─────────────────────┐                      ┌─────────────────────┐      │
│  │   Home Onelist DB   │                      │   Work Onelist DB   │      │
│  │                     │                      │                     │      │
│  │   memory_abc123 ✓   │                      │   memory_abc123 ✓   │      │
│  │   memory_def456 ✓   │◄─── both instances   │   memory_def456 ✓   │      │
│  │                     │     now have both    │                     │      │
│  │   (2 memories)      │     memories!        │   (2 memories)      │      │
│  └─────────────────────┘                      └─────────────────────┘      │
│                                                                              │
│  Note: Local FILES are different on each instance:                          │
│  • Home files: only &quot;buy milk&quot; (what home OpenClaw wrote)                   │
│  • Work files: only &quot;meeting 3pm&quot; (what work OpenClaw wrote)                │
│  But local DBs have BOTH memories (synced from cloud)                      │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
</strong>Key Principles:<strong>
<p>1. </strong>Each instance writes to its own files<strong> - No cross-instance file sync
2. </strong>Each instance has complete DB<strong> - All memories from all instances
3. </strong>Cloud merges, doesn't conflict<strong> - Different memories = different IDs
4. </strong>Search sees everything<strong> - DB has unified view</p>
<h3>7.3.3 Memory Identity & Deduplication</h3>
</strong>How memories are identified:<strong>
<pre><code class="language-elixir"># Each memory gets a globally unique ID
%{
  id: &quot;mem_&quot; &lt;&gt; Nanoid.generate(),  # e.g., &quot;mem_V1StGXR8_Z5jdHi6B&quot;
<p># Source tracking
  source_instance_id: &quot;inst_abc123&quot;,  # Which Onelist instance created this
  source_file_path: &quot;memory/2026-01-28.md&quot;,  # Original file (for that instance)</p>
<p># Content
  content: &quot;User prefers morning meetings&quot;,
  entry_type: &quot;memory_episode&quot;,</p>
<p># Timestamps
  created_at: ~U[2026-01-28 10:00:01Z],  # When written
  synced_at: ~U[2026-01-28 10:00:05Z],   # When synced to cloud
}
</code></pre></p>
</strong>What about duplicate content?<strong>
<pre><code class="language-">Scenario: User tells both OpenClaws the same thing
<p>Home OpenClaw: &quot;Remember I'm vegetarian&quot;  → memory_abc123
Work OpenClaw: &quot;Remember I'm vegetarian&quot;  → memory_def456</p>
<p>Result: Two memories with same content, different IDs</p>
<p>Options:
1. Keep both (simple, no data loss)
2. Reader daemon detects duplicates, suggests merge
3. User manually merges via Onelist UI</p>
<p>Recommendation: Option 1 + 2 (keep both, daemon suggests cleanup)
</code></pre></p>
<h3>7.3.4 Conflict Scenarios & Resolution</h3>
</strong>Scenario A: Same file modified on two instances (rare with sidecar model)<strong>
<p>This shouldn't happen often because:
<li>Each instance writes to its own files</li>
<li>Files are identified by instance_id + file_path</li>
<li>Same file path on different instances = different memories</li></p>
<p>But if it somehow happens (e.g., user manually copies files):</p>
<pre><code class="language-">Resolution: Last-write-wins with history preserved
<li>Both versions stored in representation_versions</li>
<li>Most recent becomes current</li>
<li>User can view/restore older version</li>
</code></pre>
</strong>Scenario B: Conflicting facts<strong>
<pre><code class="language-">10:00 AM - Home OpenClaw: &quot;User's favorite color is blue&quot;
10:05 AM - Work OpenClaw: &quot;User's favorite color is green&quot;
<p>Resolution:
<li>Both stored as separate memory_fact entries</li>
<li>Reader daemon can detect semantic conflict</li>
<li>Options:</li>
  a) Keep both (let user clarify)
  b) Prefer most recent
  c) Ask user to resolve</p>
<p>Recommendation: Keep both, surface conflict to user
&quot;I have conflicting information about your favorite color.
 Is it blue (from Jan 28 10:00) or green (from Jan 28 10:05)?&quot;
</code></pre></p>
</strong>Scenario C: Rapid writes during offline period<strong>
<pre><code class="language-">Instance A goes offline at 10:00 AM with 100 memories
Instance A writes 50 new memories while offline
Instance A comes back online at 6:00 PM
<p>Sync process:
1. Instance A uploads 50 new memories to cloud
2. Cloud accepts all (no conflicts - new memories)
3. Instance A downloads any memories from other instances
4. All instances now have complete set
</code></pre></p>
<h3>7.3.5 User Experience: Multi-Instance Setup</h3>
</strong>First-time setup of second instance:<strong>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                    ONELIST SKILL - FIRST RUN                                │
│                                                                              │
│  Welcome to Onelist Memory for OpenClaw!                                     │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  ○ New Onelist account (start fresh)                                │   │
│  │  ● Connect to existing account (sync existing memories)             │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  [Continue]                                                                  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
<p>▼</p>
<p>┌─────────────────────────────────────────────────────────────────────────────┐
│                    SYNCING EXISTING MEMORIES                                │
│                                                                              │
│  Found 10,247 memories in your Onelist account.                             │
│                                                                              │
│  Syncing to this device...                                                  │
│                                                                              │
│  ████████████████████░░░░░░░░░░  67%                                       │
│                                                                              │
│  • 6,865 memories synced                                                    │
│  • 3,382 remaining                                                          │
│  • Estimated time: 2 minutes                                                │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  ℹ️  Your OpenClaw can start using memories immediately.             │   │
│  │     Older memories will appear as sync completes.                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  [Use OpenClaw Now]  [Wait for Full Sync]                                    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘</p>
<p>▼</p>
<p>┌─────────────────────────────────────────────────────────────────────────────┐
│                    SYNC COMPLETE                                            │
│                                                                              │
│  ✓ 10,247 memories synced                                                   │
│  ✓ Embeddings ready for semantic search                                     │
│  ✓ Connected to Onelist cloud                                               │
│                                                                              │
│  This instance is now part of your Onelist network:                         │
│                                                                              │
│  • MacBook Pro (this device) - NEW                                          │
│  • Mac Mini (home) - last synced 5 min ago                                  │
│  • iPhone (mobile) - last synced 2 hours ago                                │
│                                                                              │
│  All instances share the same memories.                                     │
│  New memories sync automatically.                                           │
│                                                                              │
│  [Done]                                                                      │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre></p>
<h3>7.4 Sync State Machine</h3>
<pre><code class="language-">┌─────────┐
│ Created │ ─── Local save ──→ ┌─────────────┐
└─────────┘                    │ Pending Sync│
                               └──────┬──────┘
                                      │
                            Sync success │ Sync failure
                                      ▼           │
                               ┌──────────┐       │
                               │  Synced  │ ←─────┘
                               └────┬─────┘   (retry)
                                    │
                         Cloud has newer version
                                    │
                                    ▼
                               ┌──────────┐
                               │ Conflict │
                               └────┬─────┘
                                    │
                            User resolves conflict
                                    │
                                    ▼
                               ┌──────────┐
                               │  Synced  │
                               └──────────┘
</code></pre>
<hr>
<h2>8. End-to-End Encryption</h2>
<h3>8.1 Threat Model</h3>
<li></strong>Cloud provider<strong> (us, when hosting) cannot read user data</li>
<li></strong>Network attackers<strong> cannot intercept meaningful data</li>
<li></strong>Local attacker with disk access<strong> is out of scope (local is plaintext for search)</li>
<h3>8.2 Key Management</h3>
</strong>DECIDED: Passphrase Requirements & Generation<strong>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                    CREATE ENCRYPTION PASSPHRASE                             │
│                                                                              │
│  Your passphrase encrypts all your data. Choose a strong one.              │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Suggested passphrase (click to use):                                │   │
│  │                                                                      │   │
│  │    Maple7thunder-BICYCLE4quiet-Stone                                 │   │
│  │                                                      [↻ Generate]   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  Or enter your own:                                                         │
│  [_______________________________________________]                          │
│                                                                              │
│  Strength: ████████████░░░░  Strong                                        │
│                                                                              │
│  Requirements:                                                              │
│  ✅ At least 20 characters                                                  │
│  ✅ Mix of uppercase and lowercase                                          │
│  ✅ Contains numbers or special characters                                  │
│                                                                              │
│  ⚠️  IMPORTANT: If you lose this passphrase, your data CANNOT be recovered.│
│                                                                              │
│  📸 We recommend taking a photo of your passphrase and storing it          │
│     securely. If you lose it, you'll need to reset your account and        │
│     re-sync from a local device (if you still have one).                   │
│                                                                              │
│  [Continue]                                                                  │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
</strong>Auto-generated passphrase format:<strong>
<li>5 random words from wordlist</li>
<li>Each word randomly: lowercase, Initial Case, or UPPERCASE</li>
<li>Separated randomly by: numbers (0-9), dashes (-), or special characters (!@#$%&<em>)</li>
<li>Example: <code>Maple7thunder-BICYCLE4quiet-Stone</code></li>
<h4>8.2.1 Key Derivation</h4>
<pre><code class="language-">User Passphrase
         │
         ▼
    ┌─────────┐
    │ Argon2id │ (memory-hard, resistant to GPU attacks)
    │ + Salt   │
    └────┬────┘
         │
         ▼
    Master Key (256-bit)
         │
    ┌────┴────┐
    ▼         ▼
Auth Key   Encryption Key
(for API)  (for content)
</code></pre>
<h4>8.2.2 Per-Entry Encryption</h4>
<li>Each entry encrypted with unique Data Encryption Key (DEK)</li>
<li>DEK wrapped with user's Encryption Key</li>
<li>Enables future key rotation without re-encrypting all data</li>
<pre><code class="language-">Entry Content
      │
      ▼
┌───────────┐
│ AES-256-GCM │ ← Random DEK (per entry)
└─────┬─────┘
      │
      ▼
Encrypted Content + Encrypted DEK (wrapped with user's key)
</code></pre>
<h3>8.3 Recovery Key</h3>
</strong>DECIDED: Recovery Key Generation<strong>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                    RECOVERY KEY                                             │
│                                                                              │
│  Your recovery key can restore access if you forget your passphrase.       │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                      │   │
│  │    ABCD-EFGH-IJKL-MNOP-QRST-UVWX-YZ12-3456                         │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  📸 Take a photo or screenshot of this key                                  │
│  🖨️  Print and store it in a safe place                                    │
│                                                                              │
│  ⚠️  Anyone with this key can access your account.                         │
│     Store it separately from your passphrase.                              │
│                                                                              │
│  ☑️  I have saved my recovery key securely                                 │
│                                                                              │
│  [Continue]                                                                  │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
</strong>Recovery key implementation:<strong>
<li>256-bit random key, encoded as 8 groups of 4 characters</li>
<li>Encrypted copy of master key stored in cloud, encrypted by recovery key</li>
<li>Recovery flow: Enter recovery key → Decrypt master key → Set new passphrase</li>
<h3>8.4 Multi-Device Key Sharing</h3>
</strong>DECIDED: Adding New Devices<strong>
<p>Two options for setting up additional devices:</p>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                    ADD THIS DEVICE                                          │
│                                                                              │
│  Choose how to connect this device to your account:                        │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  ○ Enter passphrase                                                  │   │
│  │    Type your encryption passphrase                                   │   │
│  │                                                                      │   │
│  │  ○ Scan QR code from another device                                  │   │
│  │    Quick setup using your phone or existing device                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  [Continue]                                                                  │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
</strong>Option 1: Enter Passphrase<strong>
<li>User types passphrase on new device</li>
<li>Key derived locally using same Argon2 parameters</li>
<li>Syncs and decrypts data from cloud</li>
</strong>Option 2: QR Code (for iOS/Android companion apps)<strong>
<pre><code class="language-">EXISTING DEVICE:                          NEW DEVICE (phone):
┌─────────────────────────┐              ┌─────────────────────────┐
│                         │              │                         │
│   Add New Device        │              │   Scan this QR code     │
│                         │              │   with your other       │
│   ┌─────────────────┐   │              │   device                │
│   │  ▄▄▄▄▄▄▄▄▄▄▄   │   │              │                         │
│   │  █ QR CODE █   │   │   ──scan──►  │   [Camera viewfinder]   │
│   │  ▀▀▀▀▀▀▀▀▀▀▀   │   │              │                         │
│   └─────────────────┘   │              │                         │
│                         │              │   ✓ Device added!       │
│   Expires in 5:00       │              │                         │
└─────────────────────────┘              └─────────────────────────┘
</code></pre>
</strong>QR code contains:<strong>
<li>One-time encrypted payload with device authorization token</li>
<li>Encrypted master key (encrypted with session key)</li>
<li>Expires after 5 minutes or first use</li>
<h3>8.5 What's Encrypted vs. Not</h3>
<table>
<tr><th>Data</th><th>Encrypted</th><th>Rationale</th></tr>
<tr><td>Entry content</td><td>Yes</td><td>Core privacy requirement</td></tr>
<tr><td>Representation content</td><td>Yes</td><td>Core privacy requirement</td></tr>
<tr><td>Embeddings</td><td>Yes</td><td>Embeddings can leak semantic info</td></tr>
<tr><td>Entry titles</td><td>Yes</td><td>Often contain sensitive info</td></tr>
<tr><td>Tags</td><td>Configurable</td><td>Trade-off: encrypted = no cloud filtering</td></tr>
<tr><td>Timestamps</td><td>No</td><td>Needed for sync coordination</td></tr>
<tr><td>Entry types</td><td>No</td><td>Needed for basic cloud operations</td></tr>
<tr><td>Vector clocks</td><td>No</td><td>Needed for conflict detection</td></tr>
</table>
<h3>8.6 Key Rotation</h3>
<li>[ ] User changes passphrase → Re-wrap all DEKs with new key</li>
<li>[ ] Old passphrase no longer works after rotation</li>
<li>[ ] Recovery key should also be regenerated (optional but recommended)</li>
<hr>
<h2>9. Search & Retrieval</h2>
<h3>9.1 Search Architecture (Local Only)</h3>
<pre><code class="language-">Search Query
      │
      ├──────────────────┬───────────────────┐
      ▼                  ▼                   ▼
┌──────────┐      ┌──────────┐       ┌──────────┐
│ Keyword  │      │ Semantic │       │ Filters  │
│ (FTS)    │      │ (Vector) │       │ (SQL)    │
└────┬─────┘      └────┬─────┘       └────┬─────┘
     │                 │                  │
     ▼                 ▼                  ▼
┌──────────────────────────────────────────────┐
│              Result Fusion                    │
│  (Reciprocal Rank Fusion or learned weights) │
└──────────────────────────────────────────────┘
      │
      ▼
Ranked Results
</code></pre>
<h3>9.2 Full-Text Search (Existing Plan)</h3>
<p>Already planned:
<li><code>tsvector</code> column on <code>entries</code> or <code>representations</code></li>
<li>GIN index</li>
<li>Query via <code>to_tsquery</code></li></p>
<p>Additions needed:
<li>[ ] Weighting by field (title > content)</li>
<li>[ ] Stemming configuration (English default, configurable)</li>
<li>[ ] Phrase matching support</li></p>
<h3>9.3 Vector Search (New)</h3>
<p>Implementation:
<li><code>pgvector</code> extension</li>
<li>IVFFlat or HNSW index (HNSW preferred for accuracy)</li>
<li>Cosine similarity for search</li></p>
<pre><code class="language-sql">-- HNSW index (better accuracy, more memory)
CREATE INDEX ON embeddings USING hnsw (vector vector_cosine_ops);
<p>-- Search query
SELECT e.</em>, 1 - (emb.vector &lt;=&gt; query_vector) as similarity
FROM embeddings emb
JOIN representations r ON r.id = emb.representation_id
JOIN entries e ON e.id = r.entry_id
WHERE e.user_id = $1
  AND e.entry_type = ANY($2)
ORDER BY emb.vector &lt;=&gt; query_vector
LIMIT 20;
</code></pre></p>
<h3>9.4 Hybrid Search Fusion</h3>
</strong>Reciprocal Rank Fusion (RRF):<strong>
<pre><code class="language-">score(doc) = Σ 1 / (k + rank_i(doc))
<p>where k = 60 (standard constant)
      rank_i = rank in result set i
</code></pre></p>
</strong>Weighted Combination:<strong>
<pre><code class="language-">score(doc) = w_semantic <em> similarity_score + w_keyword </em> bm25_score
<p>where weights are configurable (default: 0.7 semantic, 0.3 keyword)
</code></pre></p>
<h3>9.5 Search UX Considerations</h3>
<li>[ ] </strong>Typeahead/autocomplete<strong>: For human users in web UI</li>
<li>[ ] </strong>Search history<strong>: Track what queries led to successful retrievals</li>
<li>[ ] </strong>"More like this"<strong>: Find similar memories to a given one</li>
<li>[ ] </strong>Negative search<strong>: "Find X but not Y"</li>
<hr>
<h2>10. Memory Management</h2>
<h3>10.1 Memory Lifecycle</h3>
<pre><code class="language-">┌─────────┐    ┌─────────┐    ┌─────────┐    ┌──────────┐
│ Created │ →  │ Active  │ →  │ Decaying│ →  │ Archived │
└─────────┘    └─────────┘    └─────────┘    └──────────┘
                    │              │               │
                    ▼              ▼               ▼
              High relevance  Decreasing      Low relevance
              in search       relevance       excluded from
                                              default search
</code></pre>
<h3>10.2 Compaction Strategies</h3>
<h4>10.2.1 Episode Summarization</h4>
<li></strong>Trigger<strong>: Episodes older than N days (configurable, default 7)</li>
<li></strong>Process<strong>:</li>
  1. Group episodes by day/week
  2. Generate summary via LLM
  3. Create <code>memory_summary</code> entry
  4. Link summary to original episodes
  5. Optionally archive originals (keep for retrieval, lower ranking)
<h4>10.2.2 Fact Deduplication</h4>
<li></strong>Trigger<strong>: Weekly job or when fact count exceeds threshold</li>
<li></strong>Process<strong>:</li>
  1. Find semantically similar facts (vector similarity > 0.95)
  2. Present candidates to LLM for merge decision
  3. Create merged fact with combined sources
  4. Archive or delete originals
<h4>10.2.3 Profile Refresh</h4>
<li></strong>Trigger<strong>: Daily or on significant new data</li>
<li></strong>Process<strong>:</li>
  1. Gather recent episodes and facts
  2. Extract user preferences, patterns, traits
  3. Update <code>memory_profile</code> entry
  4. Track profile changes over time (versioned)
<h3>10.3 Decay Algorithms</h3>
</strong>Exponential Decay:<strong>
<pre><code class="language-">relevance(t) = initial_relevance <em> e^(-λ </em> days_since_access)
<p>where λ = decay_rate (configurable per entry_type)
</code></pre></p>
</strong>Access-Based Boost:<strong>
<pre><code class="language-">effective_relevance = base_relevance <em> (1 + log(access_count + 1))
</code></pre>
<h3>10.4 Storage Tiers (Future)</h3>
<table>
<tr><th>Tier</th><th>Description</th><th>Search Included</th><th>Storage Cost</th></tr>
<tr><td>Hot</td><td>Active memories</td><td>Yes, full ranking</td><td>High</td></tr>
<tr><td>Warm</td><td>Archived but accessible</td><td>Yes, lower ranking</td><td>Medium</td></tr>
<tr><td>Cold</td><td>Compressed/summarized only</td><td>Summary only</td><td>Low</td></tr>
<tr><td>Deleted</td><td>Soft-deleted, recoverable</td><td>No</td><td>Minimal</td></tr>
</table>
<h3>10.5 Memory Hierarchy Pattern</h3>
</strong>See:<strong> <code>roadmap/future_roadmap_ai_memory_patterns.md</code> for complete implementation details.
<p>Onelist implements a four-layer memory hierarchy inspired by the "bed/sheet/clothes/pillow" conceptual model:</p>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                         MEMORY HIERARCHY SUMMARY                             │
│                                                                              │
│  Layer 1: FOUNDATIONAL (&quot;The Bed&quot;)                                          │
│  ─────────────────────────────────                                          │
│  entry_type: 'core_memory' | tags: ['memory:foundational']                  │
│  Examples: User name, timezone, critical rules                              │
│  Lifespan: Permanent | Loading: Always in context                           │
│                                                                              │
│  Layer 2: PROFILE (&quot;The Sheet&quot;)                                             │
│  ─────────────────────────────────                                          │
│  entry_type: 'preference' | tags: ['memory:profile']                        │
│  Examples: Communication style, work patterns                               │
│  Lifespan: Evolves | Loading: Topic-based pre-loading                       │
│                                                                              │
│  Layer 3: EPISODIC (&quot;The Clothes&quot;)                                          │
│  ───────────────────────────────────                                        │
│  entry_type: 'memory' | tags: ['memory:episodic', 'session:{id}']           │
│  Examples: Recent conversations, open threads                               │
│  Lifespan: Days→weeks (compacted) | Loading: Recency + relevance            │
│                                                                              │
│  Layer 4: TASK-SPECIFIC (&quot;The Pillow&quot;)                                      │
│  ─────────────────────────────────────                                      │
│  entry_type: 'derived_insight' | tags: ['memory:working']                   │
│  Examples: Synthesized answers, research findings                           │
│  Lifespan: Minutes→hours | Loading: Generated on-demand                     │
│                                                                              │
│  TOKEN BUDGET: ~1,200-3,800 tokens (vs. unbounded naive approaches)         │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
</strong>Implementation with Onelist Primitives:<strong>
<table>
<tr><th>Layer</th><th>entry_type</th><th>Tags</th><th>Key Metadata</th><th>Retrieval Strategy</th></tr>
<tr><td>Foundational</td><td><code>core_memory</code></td><td><code>memory:foundational</code></td><td><code>immutable: true</code></td><td>Always loaded</td></tr>
<tr><td>Profile</td><td><code>preference</code>, <code>behavioral_pattern</code></td><td><code>memory:profile</code></td><td><code>confidence</code>, <code>last_observed</code></td><td>Pre-loaded by topic</td></tr>
<tr><td>Episodic</td><td><code>memory</code>, <code>conversation_summary</code></td><td><code>memory:episodic</code></td><td><code>session_id</code>, <code>channel</code></td><td>Hybrid search by recency</td></tr>
<tr><td>Task-Specific</td><td><code>derived_insight</code>, <code>working_memory</code></td><td><code>memory:working</code></td><td><code>task_id</code>, <code>ttl</code></td><td>Generated on-demand</td></tr>
</table>
</strong>Key Patterns:<strong>
<li></strong>Representation Strategy<strong>: Store <code>summary</code> representations for token-efficient context loading</li>
<li></strong>Proactive Retrieval<strong>: Pre-load memories based on intent classification (don't rely on LLM tool calls)</li>
<li></strong>Relevance Scoring<strong>: Combine recency, access frequency, link count, explicit importance</li>
<li></strong>Compaction Pipeline<strong>: Daily → Weekly → Monthly summaries with archival</li>
<hr>
<h2>11. Performance Considerations</h2>
<h3>11.1 Embedding Generation</h3>
</strong>Challenge<strong>: Embedding generation is slow and potentially costly.
</strong>Mitigations:<strong>
<li>[ ] Batch embedding requests</li>
<li>[ ] Background processing via Oban (don't block writes)</li>
<li>[ ] Local model option (Ollama, etc.) for privacy and cost</li>
<li>[ ] Embedding cache for repeated content</li>
<li>[ ] Lazy embedding (generate on first search, not on write)</li>
</strong>Benchmarks Needed:<strong>
<li>[ ] Time to embed 1000 memories with OpenAI API</li>
<li>[ ] Time to embed 1000 memories with local model</li>
<li>[ ] Impact of embedding dimensions on search performance</li>
<h3>11.2 Search Latency</h3>
</strong>Target<strong>: < 200ms for hybrid search on 100k memories
</strong>Optimizations:<strong>
<li>[ ] HNSW index with appropriate <code>ef_construction</code> and <code>m</code> parameters</li>
<li>[ ] Prefiltering before vector search (narrow by entry_type, date)</li>
<li>[ ] Connection pooling for embedding API calls</li>
<li>[ ] Result caching for repeated queries</li>
<h3>11.3 Sync Performance</h3>
</strong>Target<strong>: Initial sync of 10k memories < 30 seconds
</strong>Optimizations:<strong>
<li>[ ] Delta sync (only changed entries)</li>
<li>[ ] Compression before encryption</li>
<li>[ ] Parallel upload/download</li>
<li>[ ] Resume interrupted syncs</li>
<h3>11.4 Database Sizing</h3>
</strong>Estimates for 100k memories:<strong>
<table>
<tr><th>Component</th><th>Size Estimate</th></tr>
<tr><td>Entries table</td><td>~50 MB</td></tr>
<tr><td>Representations (text)</td><td>~500 MB</td></tr>
<tr><td>Embeddings (1536-dim)</td><td>~600 MB</td></tr>
<tr><td>Indexes</td><td>~200 MB</td></tr>
<tr><td></strong>Total<strong></td><td></strong>~1.5 GB<strong></td></tr>
</table>
<hr>
<h2>12. Security Considerations</h2>
<h3>12.1 Account & Authentication Flow</h3>
</strong>DECIDED: Account Creation<strong>
<li>[x] </strong>Web signup only<strong> - Users must create accounts on website</li>
<li>[x] Mac/iOS apps show "Create Account" button that opens enrollment page in browser</li>
<li>[x] Apps cannot create accounts directly (avoids App Store payment complications)</li>
</strong>DECIDED: Authentication Methods (User Choice at Login)<strong>
1. </strong>Email magic link<strong> (default/recommended) - Click link in email to authenticate
2. </strong>Email/password<strong> (fallback) - Traditional login for users who prefer it
3. </strong>OAuth options<strong> - Google, Apple, GitHub for convenience
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                         LOGIN PAGE                                          │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  Email: [_______________________]                                    │   │
│  │                                                                      │   │
│  │  [Send Magic Link]  (recommended)                                    │   │
│  │                                                                      │   │
│  │  ─── or ───                                                          │   │
│  │                                                                      │   │
│  │  [Sign in with Password]                                             │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  ─────────────────── or continue with ───────────────────                   │
│                                                                              │
│  [Google]  [Apple]  [GitHub]                                                │
│                                                                              │
│  Don't have an account? [Sign up]                                           │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
</strong>DECIDED: Mac/iOS App Authentication<strong>
<li>[x] Email/password login directly in app (native UI, not WebView)</li>
<li>[x] On successful auth, server returns API token</li>
<li>[x] Token stored securely in local Keychain</li>
<li>[x] Token used for all subsequent API calls to headless cloud</li>
<li>[x] Token refresh handled automatically</li>
<pre><code class="language-">App Auth Flow:
1. User enters email/password in native app UI
2. App calls POST /api/auth/login
3. Server validates, returns { token: &quot;...&quot;, expires_at: &quot;...&quot; }
4. App stores token in Keychain
5. All API calls include Authorization: Bearer &lt;token&gt;
</code></pre>
<h3>12.2 API Authentication</h3>
<li>[ ] Existing <code>phx.gen.auth</code> for web UI</li>
<li>[ ] API tokens for app/agent access (issued at login)</li>
<li>[ ] Per-token scopes (read-only, write, admin)</li>
<li>[ ] Rate limiting per token (existing via <code>plug_attack</code>)</li>
<li>[ ] Token expiry and refresh mechanism</li>
<h3>12.2 API Security</h3>
<li>[ ] Input validation on all endpoints</li>
<li>[ ] SQL injection prevention (Ecto parameterized queries)</li>
<li>[ ] Embedding injection attacks (sanitize before embedding)</li>
<li>[ ] Size limits on content/embeddings</li>
<h3>12.3 Encryption Security</h3>
<li>[ ] Use well-vetted crypto libraries (libsodium via <code>cloak</code>)</li>
<li>[ ] No custom crypto implementations</li>
<li>[ ] Secure key derivation (PBKDF2, Argon2)</li>
<li>[ ] Authenticated encryption (AES-GCM)</li>
<h3>12.4 Operational Security</h3>
<li>[ ] No plaintext secrets in logs</li>
<li>[ ] Audit logging for admin actions</li>
<li>[ ] Secure defaults (no public endpoints without auth)</li>
<li>[ ] Regular dependency audits (<code>mix deps.audit</code>)</li>
<hr>
<h2>13. Business & Licensing</h2>
<h3>13.1 Open Source License Options</h3>
<table>
<tr><th>License</th><th>Pros</th><th>Cons</th></tr>
<tr><td>AGPL-3.0</td><td>Strong copyleft; competitors must open source</td><td>May deter some enterprise adoption</td></tr>
<tr><td>Apache-2.0</td><td>Permissive; wide adoption</td><td>Competitors can close-source</td></tr>
<tr><td>BSL (Business Source)</td><td>Time-delayed open source</td><td>Not OSI-approved</td></tr>
<tr><td>Elastic License 2.0</td><td>Prevents competing SaaS</td><td>Not OSI-approved</td></tr>
</table>
</strong>Recommendation<strong>: AGPL-3.0 or consider Elastic License 2.0 with 3-year conversion to Apache.
<h3>13.2 Hosted Service Tiers (Revised)</h3>
<h4>13.2.1 Pricing Philosophy</h4>
</strong>Two distinct products with different trust models:<strong>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────┐
│  TIER 1: SYNC STORAGE (Zero-Knowledge)                              │
│  ─────────────────────────────────────                              │
│  • Cloud stores encrypted blobs only                                │
│  • We CANNOT read your data (E2EE)                                  │
│  • UI/search runs locally (Mac app, self-hosted, etc.)              │
│  • Lower cost (just storage + bandwidth)                            │
└─────────────────────────────────────────────────────────────────────┘
<p>┌─────────────────────────────────────────────────────────────────────┐
│  TIER 2: DEDICATED VM (Traditional Trust)                           │
│  ───────────────────────────────────────                            │
│  • We spin up a VM for you                                          │
│  • Full web access from anywhere                                    │
│  • We COULD read your data (but won't; encrypted at rest)           │
│  • Higher cost (compute + storage + bandwidth)                      │
└─────────────────────────────────────────────────────────────────────┘
</code></pre></p>
<h4>13.2.2 Tier 1: Sync Storage (Zero-Knowledge)</h4>
</strong>Base subscription + usage:<strong>
<table>
<tr><th>Component</th><th>Pricing</th><th>Notes</th></tr>
<tr><td></strong>Base Fee<strong></td><td>$3/mo minimum</td><td>Keeps account active</td></tr>
<tr><td></strong>Storage<strong></td><td>$0.10/GB/mo</td><td>E2EE blobs (entries, representations)</td></tr>
<tr><td></strong>Sync Bandwidth<strong></td><td>$0.05/GB</td><td>Upload + download combined</td></tr>
<tr><td></strong>Devices<strong></td><td>Unlimited</td><td>No artificial limits</td></tr>
</table>
</strong>Asset Storage Tiers (choose one):<strong>
<table>
<tr><th>Tier</th><th>Providers</th><th>Price</th><th>Description</th></tr>
<tr><td></strong>Standard<strong></td><td>Cloudflare R2</td><td>$0.02/GB/mo</td><td>Single provider, fast, no egress fees</td></tr>
<tr><td></strong>Redundant<strong></td><td>R2 + Backblaze B2</td><td>$0.035/GB/mo</td><td>Automatic failover, geographic redundancy</td></tr>
</table>
</strong>Credit system:<strong>
<li>Pre-purchase credits (e.g., $10 → $12 value)</li>
<li>Auto-charge when balance low (user sets limit)</li>
<li>Monthly spending cap option (e.g., "never charge more than $20/mo")</li>
<li>Unused credits roll over</li>
</strong>Example monthly bills:<strong>
<pre><code class="language-">Light user (text only, Standard storage):
  Base fee:              $3.00
  Storage (500 MB):      $0.05
  Bandwidth (1 GB):      $0.05
  Total:                 $3.10/mo
<p>Heavy user (lots of media, Standard storage):
  Base fee:              $3.00
  Storage (5 GB):        $0.50
  Assets (50 GB @ $0.02):$1.00
  Bandwidth (10 GB):     $0.50
  Total:                 $5.00/mo</p>
<p>Power user (Redundant storage):
  Base fee:              $3.00
  Storage (20 GB):       $2.00
  Assets (200 GB @ $0.035): $7.00
  Bandwidth (30 GB):     $1.50
  Total:                 $13.50/mo
</code></pre></p>
</strong>Future: BYOB Add-ons (Post-MVP)<strong>
<li>Add own bucket alongside our storage (Standard or Redundant)</li>
<li>Replace our storage entirely with own bucket(s)</li>
<li>Migration fees: $0.01-0.02/GB to move off our buckets (covers egress)</li>
<h4>13.2.3 Tier 2: Dedicated VM</h4>
</strong>For users who want web access without local infrastructure:<strong>
<table>
<tr><th>Plan</th><th>Price</th><th>Specs</th><th>Features</th></tr>
<tr><td></strong>Starter VM<strong></td><td>$15/mo</td><td>1 vCPU, 2GB RAM, 20GB storage</td><td>Web UI, API, basic agents</td></tr>
<tr><td></strong>Standard VM<strong></td><td>$30/mo</td><td>2 vCPU, 4GB RAM, 50GB storage</td><td>+ All agents, priority support</td></tr>
<tr><td></strong>Pro VM<strong></td><td>$60/mo</td><td>4 vCPU, 8GB RAM, 200GB storage</td><td>+ Custom domain, SLA</td></tr>
</table>
</strong>What you get:<strong>
<li><code>https://username.onelist.cloud</code> web access</li>
<li>Full API access</li>
<li>Automatic backups</li>
<li>Optional: Run agents (Reader, Searcher, etc.) in cloud</li>
<li>Still syncs to local instances if desired</li>
</strong>Overage:<strong>
<li>Storage beyond plan: $0.10/GB/mo</li>
<li>Asset storage: Same tiers as Tier 1 (Standard $0.02/GB or Redundant $0.035/GB)</li>
<h4>13.2.4 Free Tier</h4>
<table>
<tr><th>Feature</th><th>Limit</th></tr>
<tr><td>Storage</td><td>100 MB (E2EE)</td></tr>
<tr><td>S3 assets</td><td>500 MB</td></tr>
<tr><td>Devices</td><td>2</td></tr>
<tr><td>Features</td><td>Basic sync only</td></tr>
</table>
</strong>Purpose:<strong> Let users try the system, not be forever-free tier.
<h3>13.3 Revenue Opportunities</h3>
<li>[ ] </strong>Primary:<strong> Sync storage (Tier 1) - Usage-based, scales with users</li>
<li>[ ] </strong>Secondary:<strong> VM hosting (Tier 2) - Higher margin, stickier customers</li>
<li>[ ] </strong>Future:<strong> Premium compaction (use better LLMs for summarization)</li>
<li>[ ] </strong>Future:<strong> Enterprise features (SSO, audit logs, compliance, on-prem support)</li>
<li>[ ] </strong>Future:<strong> Marketplace for skills/integrations (take percentage)</li>
<li>[ ] </strong>Future:<strong> White-label licensing (let others build on Onelist)</li>
<h3>13.4 Billing Infrastructure</h3>
</strong>DECIDED: Billing Integration<strong>
<li>[x] </strong>Stripe Checkout<strong> for initial purchase and plan changes</li>
<li>[x] </strong>Stripe Customer Portal<strong> for self-service billing management</li>
<li>[x] Storage tier selected during signup flow (not deferred)</li>
</strong>Signup Flow:<strong>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────────────┐
│                         SIGNUP FLOW                                         │
│                                                                              │
│  1. Create Account                    2. Select Plan                        │
│  ┌─────────────────────────────┐     ┌─────────────────────────────┐       │
│  │ Email: [________________]   │     │ Storage Tier:               │       │
│  │ Password: [_____________]   │ ──► │ ○ Standard ($0.02/GB)       │       │
│  │                             │     │ ● Redundant ($0.035/GB)     │       │
│  │ [Create Account]            │     │                             │       │
│  └─────────────────────────────┘     │ [Continue to Payment]       │       │
│                                      └─────────────────────────────┘       │
│                                                 │                           │
│                                                 ▼                           │
│                                      ┌─────────────────────────────┐       │
│                                      │   Stripe Checkout           │       │
│                                      │   (hosted payment page)     │       │
│                                      └─────────────────────────────┘       │
│                                                 │                           │
│                                                 ▼                           │
│                                      ┌─────────────────────────────┐       │
│                                      │   Success! Download App     │       │
│                                      │   [Mac]  [iOS]  [Docker]    │       │
│                                      └─────────────────────────────┘       │
└─────────────────────────────────────────────────────────────────────────────┘
</code></pre>
</strong>Billing Portal (via Stripe Customer Portal):<strong>
<li>Current plan display</li>
<li>Storage tier (Standard/Redundant) - change triggers Stripe Checkout</li>
<li>Usage stats (storage used, bandwidth)</li>
<li>Credit balance</li>
<li>Payment method management</li>
<li>Invoice history</li>
</strong>Usage Dashboard (our UI, not Stripe):<strong>
<pre><code class="language-">┌─────────────────────────────────────────────────────────────────────┐
│                    USAGE DASHBOARD                                  │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │  Credit Balance: $47.50                                       │ │
│  │  ├── Pre-purchased: $50.00                                    │ │
│  │  └── Used this month: $2.50                                   │ │
│  │                                                                │ │
│  │  Auto-charge: ON (when balance &lt; $10, add $25)                │ │
│  │  Monthly cap: $50 (won't charge beyond this)                  │ │
│  │                                                                │ │
│  │  This month's usage:                                          │ │
│  │  ├── Base fee:        $3.00                                   │ │
│  │  ├── Storage (2.1GB): $0.21                                   │ │
│  │  ├── Assets (15GB):   $0.30  [Standard tier]                  │ │
│  │  └── Bandwidth (5GB): $0.25                                   │ │
│  │                       ──────                                  │ │
│  │  Projected total:     $3.76                                   │ │
│  │                                                                │ │
│  │  [Manage Billing] ──► Stripe Customer Portal                  │ │
│  └───────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────┘
</code></pre>
</strong>Payment processing:<strong> Stripe (Checkout, Customer Portal, usage metering)
<h3>13.5 Competitive Positioning</h3>
<table>
<tr><th>Feature</th><th>Onelist (Tier 1)</th><th>Onelist (Tier 2)</th><th>supermemory</th><th>mem.ai</th></tr>
<tr><td>Zero-knowledge E2EE</td><td>✓</td><td>✗</td><td>✗</td><td>✗</td></tr>
<tr><td>Self-hostable</td><td>✓</td><td>N/A</td><td>✗</td><td>✗</td></tr>
<tr><td>Open source</td><td>✓</td><td>✓</td><td>Partial</td><td>✗</td></tr>
<tr><td>AI agent support</td><td>✓</td><td>✓</td><td>Limited</td><td>✗</td></tr>
<tr><td>Usage-based pricing</td><td>✓</td><td>✗ (fixed)</td><td>✗</td><td>✗</td></tr>
<tr><td>Web UI</td><td>Local only</td><td>✓</td><td>✓</td><td>✓</td></tr>
</table>
<hr>
<h2>14. Migration & Compatibility</h2>
<h3>14.1 Existing Onelist Data</h3>
<p>Current Onelist users should be able to:
<li>[ ] Continue using existing entries unchanged</li>
<li>[ ] Opt-in to memory features for existing content</li>
<li>[ ] Generate embeddings for historical entries</li></p>
<h3>14.2 OpenClaw Migration</h3>
<li>[ ] Import tool for <code>memory/</em>.md</code> files</li>
<li>[ ] Preserve timestamps from file metadata</li>
<li>[ ] Categorize content (episode vs. fact heuristics)</li>
<li>[ ] Deduplicate during import</li>
<h3>14.3 Other Memory Systems</h3>
<p>Consider future importers for:
<li>[ ] Notion exports</li>
<li>[ ] Obsidian vaults</li>
<li>[ ] Roam Research</li>
<li>[ ] Apple Notes</li>
<li>[ ] mem.ai exports</li></p>
<hr>
<h2>15. Open Questions</h2>
<h3>15.1 Technical</h3>
<li>[ ] </strong>Q1<strong>: Single embedding per representation or multiple (different models)?</li>
  <li><em>Leaning</em>: Single initially, with model name stored; support multiple later</li>
<li>[ ] </strong>Q2<strong>: How to handle embedding model upgrades?</li>
  <li><em>Options</em>: Re-embed all (expensive); dual-index during transition; accept accuracy hit</li>
<li>[ ] </strong>Q3<strong>: Should search results include "why" explanation?</li>
  <li><em>Consideration</em>: Helpful for debugging; adds latency; LLM cost</li>
<li>[ ] </strong>Q4<strong>: How aggressive should default decay be?</li>
  <li><em>Consideration</em>: Too aggressive = lost memories; too conservative = bloat</li>
<li>[ ] </strong>Q5<strong>: Should compaction require user approval?</li>
  <li><em>Consideration</em>: Safer but interrupts autonomy; maybe async approval queue</li>
<li>[ ] </strong>Q6<strong>: How to handle very long memories (> token limit)?</li>
  <li><em>Options</em>: Chunk and embed separately; summarize first; reject</li>
<h3>15.2 Product</h3>
<li>[ ] </strong>Q7<strong>: What's the minimum viable OpenClaw integration?</li>
  <li><em>Options</em>: Full skill; just API compatibility; manual config</li>
  <li><em>Leaning</em>: Full skill with transparent augmentation (daemons)</li>
<li>[ ] </strong>Q8<strong>: Should we build a OpenClaw skill ourselves or let community do it?</li>
  <li><em>Leaning</em>: Build reference implementation; encourage forks</li>
  <li><em>Note</em>: We control quality of first impression</li>
<li>[ ] </strong>Q9<strong>: How to handle the human vs. agent memory distinction?</li>
  <li><em>Consideration</em>: Same system with different UX? Separate views?</li>
  <li><em>Leaning</em>: Same storage; web UI for humans; API for agents; both see same data</li>
<li>[ ] </strong>Q10<strong>: What's the branding relationship between Onelist (human) and memory service (agent)?</li>
  <li><em>Options</em>: Same brand; sub-brand; separate product name</li>
  <li><em>Consideration</em>: "Onelist Memory" or just "Onelist"?</li>
<h3>15.2.1 Storage & Database Questions</h3>
<li>[ ] </strong>Q20<strong>: What's the right default sync mode for different devices?</li>
  <li><em>Options</em>: Full (desktop), Lean (laptop), Minimal (mobile)</li>
  <li><em>Leaning</em>: Auto-detect based on available storage</li>
<li>[x] </strong>Q21<strong>: ~~Should SQLite be the default for all local installs?~~ → </strong>DECIDED: PostgreSQL everywhere<strong></li>
  <li><em>Finding</em>: Embedded PostgreSQL is viable (~150MB), simpler than maintaining two codepaths</li>
  <li><em>Decision</em>: Bundle PostgreSQL in Mac app; same code everywhere</li>
  <li><em>Tradeoff accepted</em>: Larger app size for simpler architecture</li>
<li>[x] </strong>Q22<strong>: ~~Vectorlite vs sqlite-vec vs hybrid?~~ → </strong>DECIDED: Not needed<strong></li>
  <li><em>Finding</em>: Embedded PostgreSQL + pgvector solves the problem better</li>
  <li><em>Decision</em>: Single database engine (PostgreSQL) everywhere</li>
  <li><em>Fallback</em>: Can add SQLite+Vectorlite later if embedded PG proves problematic</li>
<li>[ ] </strong>Q22b<strong>: </strong>NEW: PostgreSQL embedding approach?<strong></li>
  <li><em>Options</em>: Bundle binaries directly; use postgresql-embedded crate; port Postgres.app approach</li>
  <li><em>Research Needed</em>: Best way to bundle PG binaries with Elixir/Burrito release</li>
  <li><em>Action</em>: Prototype embedded PostgreSQL in Mac app</li>
<li>[ ] </strong>Q23<strong>: How to handle media-heavy users on storage-constrained devices?</li>
  <li><em>Options</em>: Aggressive thumbnail-only; selective sync; cloud-only viewing</li>
  <li><em>Leaning</em>: User-configurable sync filters (by type, size, age)</li>
<li>[ ] </strong>Q24<strong>: Should Mac app include Ollama for local embeddings?</li>
  <li><em>Consideration</em>: Increases app size significantly (~4GB with model)</li>
  <li><em>Leaning</em>: No - detect if Ollama installed separately, offer download link</li>
<li>[ ] </strong>Q42<strong>: Which cloud provider should Onelist use for managed storage?</li>
  <li><em>Options</em>: Cloudflare R2 (no egress), AWS S3 (established), Backblaze B2 (cheapest)</li>
  <li><em>Leaning</em>: Cloudflare R2 - no egress fees makes costs predictable</li>
<li>[ ] </strong>Q47<strong>: Should OpenClaw asset watcher be opt-in or default?</li>
  <li><em>Options</em>: Opt-in (explicit); Default-on (seamless)</li>
  <li><em>Leaning</em>: Default-on with clear "what's being synced" visibility</li>
<li>[ ] </strong>Q48<strong>: What to do with original OpenClaw files after sync?</li>
  <li><em>Options</em>: Keep (safe), Delete (save space), Archive (move to dated folder)</li>
  <li><em>Leaning</em>: Configurable, default to keep for first 30 days</li>
</strong>BYOB Questions (Backend MVP, UI Future):<strong>
<li>[ ] </strong>Q43<strong>: Should BYOB users get a discount on Tier 1?</li>
  <li><em>Options</em>: Same price (simpler); reduced price (fair - we save on storage)</li>
  <li><em>Leaning</em>: Reduced base fee ($2/mo vs $3/mo) for BYOB users</li>
  <li><em>Note</em>: Pricing UI is post-MVP</li>
<li>[ ] </strong>Q44<strong>: How to verify BYOB bucket permissions?</li>
  <li><em>Need</em>: Test write, read, delete before saving config</li>
  <li><em>API</em>: Implement test endpoint now; UI later</li>
<li>[ ] </strong>Q45<strong>: Should we auto-detect optimal cloud region for BYOB?</li>
  <li><em>Options</em>: Let user choose; suggest based on latency test</li>
  <li><em>Consideration</em>: R2 doesn't have regions (auto), others do</li>
<li>[ ] </strong>Q46<strong>: How to handle BYOB credential rotation?</li>
  <li><em>Scenario</em>: User rotates API keys, old ones stop working</li>
  <li><em>Options</em>: Graceful failure with clear messaging; re-auth flow</li>
</strong>Multi-Cloud Redundancy Questions (Future):<strong>
<li>[ ] </strong>Q49<strong>: How many cloud backends should users be able to configure?</li>
  <li><em>Options</em>: 2 (primary + backup); unlimited (power users)</li>
  <li><em>Consideration</em>: Complexity vs. flexibility</li>
<li>[ ] </strong>Q50<strong>: Should secondary sync be immediate or async?</li>
  <li><em>Options</em>: Immediate (slower uploads, guaranteed redundancy); async (faster, eventual consistency)</li>
  <li><em>Leaning</em>: Async with configurable option</li>
<li>[ ] </strong>Q51<strong>: How to handle partial failures (primary succeeds, secondary fails)?</li>
  <li><em>Options</em>: Retry in background; alert user; mark as degraded</li>
  <li><em>Leaning</em>: Retry in background, surface in UI if persistent</li>
</strong>Storage Tier Pricing Questions:<strong>
<li>[ ] </strong>Q52<strong>: What's the right price delta between Standard and Redundant?</li>
  <li><em>Current</em>: $0.02 vs $0.035 (75% more for redundancy)</li>
  <li><em>Consideration</em>: B2 is cheap (~$0.006/GB), but we have overhead</li>
<li>[ ] </strong>Q53<strong>: Should Redundant be the default (opt-out) or Standard (opt-in)?</li>
  <li><em>Options</em>: Default to cheaper; default to safer</li>
  <li><em>Leaning</em>: Default to Redundant, let cost-conscious users downgrade</li>
<li>[ ] </strong>Q54<strong>: How to handle users switching between Standard and Redundant?</li>
  <li><em>Standard → Redundant</em>: Background job mirrors existing assets to B2</li>
  <li><em>Redundant → Standard</em>: Keep B2 copies for 30 days, then delete</li>
<li>[ ] </strong>Q55<strong>: Should migration fees be per-GB or flat rate?</li>
  <li><em>Options</em>: Per-GB (fair for small users); flat (predictable)</li>
  <li><em>Leaning</em>: Per-GB with minimum ($5 floor?)</li>
<h3>15.2.2 Mac App Questions</h3>
<li>[ ] </strong>Q25<strong>: SwiftUI wrapper vs. full Tauri app?</li>
  <li><em>Tradeoff</em>: Development speed vs. native feel</li>
  <li><em>Leaning</em>: Burrito + minimal SwiftUI for v1; evaluate Tauri for v2</li>
<li>[ ] </strong>Q26<strong>: How to handle app updates with embedded Elixir runtime?</li>
  <li><em>Consideration</em>: Auto-update vs. manual download</li>
  <li><em>Leaning</em>: Sparkle framework for macOS auto-updates</li>
<li>[ ] </strong>Q27<strong>: Should Mac app have its own web UI or menu-bar only?</li>
  <li><em>Options</em>: Menu bar + settings only; full web UI in window; both</li>
  <li><em>Leaning</em>: Menu bar primary; web UI in browser (localhost:4000)</li>
<li>[ ] </strong>Q28<strong>: How to handle agent resource usage on laptops?</li>
  <li><em>Consideration</em>: Battery drain, thermal throttling</li>
  <li><em>Leaning</em>: Agents pause on battery; configurable schedules</li>
<h3>15.2.3 Multi-Instance Questions</h3>
<li>[ ] </strong>Q29<strong>: Should synced memories be written to local files or DB-only?</li>
  <li><em>Current design</em>: DB-only (files only for local writes)</li>
  <li><em>Alternative</em>: Write to files too (full local copy)</li>
  <li><em>Tradeoff</em>: Simplicity vs. OpenClaw native file access to all memories</li>
  <li><em>Leaning</em>: DB-only; OpenClaw gets memories via search augmentation</li>
<li>[ ] </strong>Q30<strong>: How to handle large initial sync (100k+ memories)?</li>
  <li><em>Options</em>: Block until complete; progressive sync; sync most recent first</li>
  <li><em>Leaning</em>: Progressive sync, most recent first, allow use during sync</li>
<li>[ ] </strong>Q31<strong>: How many instances should we support per account?</li>
  <li><em>Consideration</em>: Sync complexity, cloud costs</li>
  <li><em>Leaning</em>: Unlimited for self-hosted; tiered for cloud (Free: 2, Pro: unlimited)</li>
<li>[ ] </strong>Q32<strong>: How to detect and surface conflicting facts across instances?</li>
  <li><em>Options</em>: Ignore (keep both); auto-resolve (most recent wins); ask user</li>
  <li><em>Leaning</em>: Keep both + Reader daemon suggests resolution</li>
<li>[ ] </strong>Q33<strong>: Should instances have names/identities visible to user?</li>
  <li><em>UX question</em>: "Memory from Mac Mini" vs. just "Memory from Jan 28"</li>
  <li><em>Leaning</em>: Yes, show instance name for transparency</li>
<h3>15.2.4 Drop-In Strategy Questions</h3>
<li>[ ] </strong>Q14<strong>: How to handle OpenClaw skill versioning as OpenClaw evolves?</li>
  <li><em>Risk</em>: OpenClaw updates break our skill</li>
  <li><em>Mitigation</em>: Pin to OpenClaw versions; responsive updates</li>
<li>[ ] </strong>Q15<strong>: Should daemons run by default or be opt-in?</li>
  <li><em>Options</em>: All-in-one default (simplest); Core-only default (explicit opt-in)</li>
  <li><em>Leaning</em>: All-in-one Docker for OpenClaw users; Core-only for developers</li>
<li>[ ] </strong>Q16<strong>: What if OpenClaw user wants to disable transparent augmentation?</li>
  <li><em>Consideration</em>: Some users want full control</li>
  <li><em>Solution</em>: Config flags in skill; can disable daemons</li>
<li>[ ] </strong>Q17<strong>: How to handle the "first search" experience?</li>
  <li><em>Issue</em>: New install has no embeddings yet; search quality starts low</li>
  <li><em>Options</em>: Block until embeddings done; warn user; fallback to FTS</li>
<li>[ ] </strong>Q18<strong>: Should import preserve OpenClaw's original file structure?</li>
  <li><em>Consideration</em>: Some users may want to rollback</li>
  <li><em>Leaning</em>: Keep original files; add <code>.onelist-imported</code> marker</li>
<li>[ ] </strong>Q19<strong>: How to communicate value to OpenClaw users?</li>
  <li><em>Challenge</em>: "Better memory" is abstract</li>
  <li><em>Ideas</em>: Before/after search comparison; token savings calculator; reliability metrics</li>
<h3>15.3 Business</h3>
<li>[ ] </strong>Q11<strong>: When to announce / launch publicly?</li>
  <li><em>Consideration</em>: OpenClaw hype is current; but need working product</li>
<li>[ ] </strong>Q12<strong>: How to position against supermemory and similar?</li>
  <li><em>Differentiator</em>: Self-hosted, E2EE, open source</li>
<li>[ ] </strong>Q13<strong>: Should hosted service be announced alongside open source?</li>
  <li><em>Consideration</em>: "Source available" perception if hosting announced first</li>
<h3>15.3.1 Deployment & Monetization Questions</h3>
<li>[ ] </strong>Q34<strong>: What's the minimum viable cloud infrastructure for Tier 1 (sync storage)?</li>
  <li><em>Options</em>: Start with single region; multi-region later</li>
  <li><em>Consideration</em>: S3-compatible storage (AWS S3, Cloudflare R2, Backblaze B2)</li>
<li>[ ] </strong>Q35<strong>: How to handle VM tier provisioning?</li>
  <li><em>Options</em>: Manual initially; Kubernetes auto-scaling later</li>
  <li><em>Consideration</em>: Fly.io machines vs AWS EC2 vs dedicated providers</li>
<li>[ ] </strong>Q36<strong>: What credit/billing system to use?</li>
  <li><em>Options</em>: Stripe Billing; custom with Stripe metered billing; third-party</li>
  <li><em>Consideration</em>: Usage metering complexity</li>
<li>[ ] </strong>Q37<strong>: Should VM tier sync with Tier 1 cloud or be standalone?</li>
  <li><em>Options</em>: Standalone (simpler); Sync (user can have both local + VM)</li>
  <li><em>Leaning</em>: Allow both - VM user can still sync to local Mac app</li>
<li>[ ] </strong>Q38<strong>: How to handle VM tier data if user downgrades?</li>
  <li><em>Options</em>: Export/migrate to Tier 1 (encrypted); Delete after grace period</li>
  <li><em>Consideration</em>: Data portability is key differentiator</li>
<li>[ ] </strong>Q39<strong>: What's the trust messaging for VM tier?</li>
  <li><em>Challenge</em>: "We could read your data but won't" is weaker than E2EE</li>
  <li><em>Options</em>: Encrypted at rest; audit logs; third-party audits; SOC 2</li>
<li>[ ] </strong>Q40<strong>: Should agents be included in VM tier or separate add-on?</li>
  <li><em>Options</em>: Include basic agents; charge for premium (better LLMs)</li>
  <li><em>Consideration</em>: Simplicity vs revenue optimization</li>
<li>[ ] </strong>Q41<strong>: How to price S3 asset storage competitively?</li>
  <li><em>Reality check</em>: S3 is ~$0.023/GB/mo; our $0.02 is below cost</li>
  <li><em>Options</em>: $0.03/GB (slight margin); $0.05/GB (comfortable margin)</li>
<hr>
<h2>16. Risk Register</h2>
<table>
<tr><th>ID</th><th>Risk</th><th>Likelihood</th><th>Impact</th><th>Mitigation</th></tr>
<tr><td>R1</td><td>OpenClaw pivots away from plugin architecture</td><td>Medium</td><td>High</td><td>Build generic memory API; don't couple too tightly</td></tr>
<tr><td>R2</td><td>pgvector performance insufficient at scale</td><td>Low</td><td>High</td><td>Benchmark early; have fallback to dedicated vector DB</td></tr>
<tr><td>R3</td><td>E2EE makes debugging user issues hard</td><td>High</td><td>Medium</td><td>Extensive local logging; user-controlled share for support</td></tr>
<tr><td>R4</td><td>Embedding API costs higher than expected</td><td>Medium</td><td>Medium</td><td>Prioritize local model support; lazy embedding</td></tr>
<tr><td>R5</td><td>Sync conflicts create poor UX</td><td>Medium</td><td>Medium</td><td>Invest in conflict resolution UI; conservative merge defaults</td></tr>
<tr><td>R6</td><td>Competition launches similar product first</td><td>Medium</td><td>Medium</td><td>Move fast; differentiate on privacy and open source</td></tr>
<tr><td>R7</td><td>Users don't trust "can't read your data" claim</td><td>Medium</td><td>Low</td><td>Open source; third-party audits; transparency reports</td></tr>
<tr><td>R8</td><td>LLM summarization quality inconsistent</td><td>High</td><td>Medium</td><td>User review of summaries; manual override option</td></tr>
<tr><td>R9</td><td></strong>OpenClaw skill breaks on OpenClaw updates<strong></td><td>High</td><td>High</td><td>Version pinning; active monitoring; quick response team</td></tr>
<tr><td>R10</td><td></strong>"Transparent augmentation" feels like magic/scary<strong></td><td>Medium</td><td>Medium</td><td>Clear docs; "what happened" logs; opt-out option</td></tr>
<tr><td>R11</td><td></strong>Import corrupts/loses existing memories<strong></td><td>Low</td><td>Critical</td><td>Backup-first import; dry-run mode; keep originals</td></tr>
<tr><td>R12</td><td></strong>Daemon overhead impacts OpenClaw performance<strong></td><td>Medium</td><td>Medium</td><td>Async-only operations; tune batch sizes; lazy processing</td></tr>
<tr><td>R13</td><td></strong>Users expect Onelist to be free forever<strong></td><td>Medium</td><td>Low</td><td>Clear communication; generous free tier; obvious value-add for paid</td></tr>
<tr><td>R14</td><td>~~sqlite-vec lacks HNSW~~ → </strong>Embedded PostgreSQL subprocess management<strong></td><td>Medium</td><td>Medium</td><td>Robust lifecycle management; graceful shutdown; handle crashes; watchdog process</td></tr>
<tr><td>R14b</td><td></strong>PostgreSQL startup time in Mac app (~2-5s)<strong></td><td>Low</td><td>Low</td><td>Show splash screen; lazy start; keep running in background</td></tr>
<tr><td>R14c</td><td></strong>Mac app size ~150-200MB<strong></td><td>Low</td><td>Low</td><td>Acceptable for desktop apps; much smaller than Electron apps; document why</td></tr>
<tr><td>R15</td><td></strong>Tiered storage confuses users ("where's my photo?")<strong></td><td>Medium</td><td>Medium</td><td>Clear UI indicators; easy "download full" action; explain on first use</td></tr>
<tr><td>R16</td><td></strong>Mac app Elixir binary size too large<strong></td><td>Low</td><td>Medium</td><td>Optimize release; consider native rewrite for v2 if critical</td></tr>
<tr><td>R17</td><td></strong>Multi-instance sync conflicts with different agents<strong></td><td>Medium</td><td>Medium</td><td>Clear "last writer wins" policy; show conflict history; manual override</td></tr>
<tr><td>R18</td><td></strong>Users run too many agents, drain laptop battery<strong></td><td>High</td><td>Low</td><td>Battery-aware scheduling; clear resource indicators; sensible defaults</td></tr>
<tr><td></strong>Deployment & Monetization Risks<strong></td></tr>
<tr><td>R19</td><td></strong>Headless cloud limits functionality (no web search)<strong></td><td>N/A</td><td>By Design</td><td>This IS the privacy model; VM tier is the alternative</td></tr>
<tr><td>R20</td><td></strong>VM tier undercuts trust narrative<strong></td><td>Medium</td><td>Medium</td><td>Clear messaging; position as "convenience vs privacy" tradeoff</td></tr>
<tr><td>R21</td><td></strong>Usage-based pricing unpredictable for users<strong></td><td>Medium</td><td>Medium</td><td>Spending caps; clear projections; "never exceed $X/mo" option</td></tr>
<tr><td>R22</td><td></strong>S3 costs higher than user storage fees<strong></td><td>Medium</td><td>High</td><td>Adjust pricing; use cheaper storage (R2, B2); tiered pricing</td></tr>
<tr><td>R23</td><td></strong>VM tier ops complexity (provisioning, maintenance)<strong></td><td>High</td><td>Medium</td><td>Start with Fly.io/managed; consider Kubernetes only at scale</td></tr>
<tr><td>R24</td><td></strong>Users accumulate credits, never use (liability)<strong></td><td>Low</td><td>Low</td><td>Credits expire after 2 years; or just accept as prepaid revenue</td></tr>
<tr><td>R25</td><td></strong>Phoenix Native (iOS) immature for production<strong></td><td>Medium</td><td>Medium</td><td>Start with Mac app; iOS can wait for Phoenix Native to mature</td></tr>
<tr><td>R26</td><td></strong>Web UI "feels slow" running locally<strong></td><td>Low</td><td>Medium</td><td>Phoenix LiveView is fast; optimize; lazy load</td></tr>
<tr><td></strong>Asset Storage & BYOB Risks<strong></td></tr>
<tr><td>R27</td><td></strong>Cloud storage costs unpredictable (egress spikes)<strong></td><td>Medium</td><td>Medium</td><td>Use R2 (no egress); tiered sync reduces downloads; usage dashboard</td></tr>
<tr><td>R28</td><td></strong>Thumbnail generation slow/resource-intensive<strong></td><td>Medium</td><td>Low</td><td>Async Oban worker; batch processing; use optimized libraries (libvips)</td></tr>
<tr><td>R29</td><td></strong>OpenClaw asset watcher misses files<strong></td><td>Medium</td><td>Medium</td><td>Use robust file watching (fswatch); periodic scan fallback; checksum verification</td></tr>
<tr><td>R30</td><td></strong>BYOB credential management complexity<strong></td><td>Medium</td><td>Medium</td><td>Clear API for setup/rotation; encrypted storage; test connection flow</td></tr>
<tr><td>R31</td><td></strong>BYOB bucket misconfiguration causes data loss<strong></td><td>Low</td><td>Critical</td><td>Verify write/read/delete before activation; never delete from old bucket until new verified</td></tr>
<tr><td>R32</td><td></strong>BYOB users harder to support (we can't see their data)<strong></td><td>High</td><td>Low</td><td>Good logging; user-initiated diagnostic export; clear BYOB documentation</td></tr>
<tr><td>R33</td><td></strong>Third-party S3 API compatibility issues<strong></td><td>Low</td><td>Medium</td><td>Test against R2, B2, Spaces explicitly; document known limitations</td></tr>
</table>
<hr>
<h2>17. Opportunity Register</h2>
<table>
<tr><th>ID</th><th>Opportunity</th><th>Potential Impact</th><th>Effort</th><th>Priority</th></tr>
<tr><td>O1</td><td>First E2EE memory backend for AI agents</td><td>High (differentiation)</td><td>High</td><td>P0</td></tr>
<tr><td>O2</td><td>Reference OpenClaw skill drives adoption</td><td>High (network effects)</td><td>Medium</td><td>P0</td></tr>
<tr><td>O3</td><td>Open source community contributes skills</td><td>High (ecosystem)</td><td>Low</td><td>P1</td></tr>
<tr><td>O4</td><td>Integration with other AI agents (not just OpenClaw)</td><td>High (market expansion)</td><td>Medium</td><td>P1</td></tr>
<tr><td>O5</td><td>Human "second brain" use case standalone</td><td>Medium (separate market)</td><td>Low</td><td>P1</td></tr>
<tr><td>O6</td><td>Enterprise offering with compliance features</td><td>High (revenue)</td><td>High</td><td>P2</td></tr>
<tr><td>O7</td><td>Marketplace for memory plugins/integrations</td><td>Medium (revenue)</td><td>Medium</td><td>P2</td></tr>
<tr><td>O8</td><td>Research partnerships (memory + AI)</td><td>Medium (credibility)</td><td>Low</td><td>P2</td></tr>
<tr><td></strong>Drop-In Strategy Opportunities<strong></td></tr>
<tr><td>O9</td><td></strong>"5-minute setup" becomes viral hook<strong></td><td>High (growth)</td><td>Low</td><td>P0</td></tr>
<tr><td>O10</td><td></strong>Token savings calculator as marketing tool<strong></td><td>Medium (conversion)</td><td>Low</td><td>P0</td></tr>
<tr><td>O11</td><td></strong>"Better search" demo video drives adoption<strong></td><td>High (awareness)</td><td>Low</td><td>P0</td></tr>
<tr><td>O12</td><td></strong>awesome-openclaw-skills listing drives discovery<strong></td><td>High (reach)</td><td>Low</td><td>P1</td></tr>
<tr><td>O13</td><td></strong>OpenClaw creator endorsement/partnership<strong></td><td>Very High (credibility)</td><td>Medium</td><td>P1</td></tr>
<tr><td>O14</td><td></strong>Skills for other AI agents (Claude Code, etc.)<strong></td><td>High (market expansion)</td><td>Medium</td><td>P1</td></tr>
<tr><td>O15</td><td></strong>Import tools for competing memory systems<strong></td><td>Medium (switching)</td><td>Medium</td><td>P2</td></tr>
<tr><td></strong>Storage & Platform Opportunities<strong></td></tr>
<tr><td>O16</td><td></strong>Mac App Store distribution<strong></td><td>High (discovery)</td><td>Medium</td><td>P1</td></tr>
<tr><td>O17</td><td></strong>"Works offline" as differentiator<strong></td><td>High (privacy users)</td><td>Low</td><td>P0</td></tr>
<tr><td>O18</td><td></strong>SQLite portability → easy backup/export<strong></td><td>Medium (trust)</td><td>Low</td><td>P1</td></tr>
<tr><td>O19</td><td></strong>Selective sync → works on any device<strong></td><td>High (accessibility)</td><td>Medium</td><td>P1</td></tr>
<tr><td>O20</td><td></strong>Agent marketplace (community agents)<strong></td><td>High (ecosystem)</td><td>High</td><td>P2</td></tr>
<tr><td>O21</td><td></strong>iOS companion app (view-only initially)<strong></td><td>Medium (convenience)</td><td>High</td><td>P2</td></tr>
<tr><td></strong>Deployment & Monetization Opportunities<strong></td></tr>
<tr><td>O22</td><td></strong>"Zero-knowledge cloud" as premium positioning<strong></td><td>High (trust)</td><td>Low</td><td>P0</td></tr>
<tr><td>O23</td><td></strong>Usage-based pricing attracts light users (low commitment)<strong></td><td>High (acquisition)</td><td>Medium</td><td>P0</td></tr>
<tr><td>O24</td><td></strong>VM tier captures users who won't self-host<strong></td><td>High (revenue)</td><td>High</td><td>P1</td></tr>
<tr><td>O25</td><td></strong>Credits system encourages prepayment (cash flow)<strong></td><td>Medium (revenue)</td><td>Low</td><td>P1</td></tr>
<tr><td>O26</td><td></strong>Multi-tier captures both privacy purists and convenience seekers<strong></td><td>High (market reach)</td><td>Medium</td><td>P1</td></tr>
<tr><td>O27</td><td></strong>Mac App Store presence legitimizes product<strong></td><td>High (trust)</td><td>Medium</td><td>P1</td></tr>
<tr><td>O28</td><td></strong>Headless cloud = simpler infra = lower ops costs<strong></td><td>Medium (margin)</td><td>N/A</td><td>P0</td></tr>
<tr><td>O29</td><td></strong>Phoenix Native enables true native iOS without rewrite<strong></td><td>High (reach)</td><td>High</td><td>P2</td></tr>
<tr><td>O30</td><td></strong>"Your data never leaves your device" messaging<strong></td><td>Very High (differentiation)</td><td>Low</td><td>P0</td></tr>
<tr><td></strong>Asset Storage & BYOB Opportunities<strong></td></tr>
<tr><td>O31</td><td></strong>OpenClaw screenshot/audio sync as killer feature<strong></td><td>High (value-add)</td><td>Medium</td><td>P0</td></tr>
<tr><td>O32</td><td></strong>OCR on screenshots enables text search of visual memories<strong></td><td>High (feature)</td><td>Medium</td><td>P1</td></tr>
<tr><td>O33</td><td></strong>Tiered sync enables low-storage devices (phones, old Macs)<strong></td><td>High (accessibility)</td><td>Medium</td><td>P1</td></tr>
<tr><td>O34</td><td></strong>BYOB appeals to enterprise/privacy-conscious users<strong></td><td>High (market segment)</td><td>Medium</td><td>P1</td></tr>
<tr><td>O35</td><td></strong>BYOB reduces our storage costs<strong></td><td>High (margin)</td><td>Medium</td><td>P1</td></tr>
<tr><td>O36</td><td></strong>"Use your existing cloud credits" messaging<strong></td><td>Medium (conversion)</td><td>Low</td><td>P1</td></tr>
<tr><td>O37</td><td></strong>Multi-cloud support (R2+B2+S3) as differentiator<strong></td><td>Medium (flexibility)</td><td>Medium</td><td>P1</td></tr>
<tr><td>O38</td><td></strong>Partnership with R2/B2 for co-marketing<strong></td><td>Medium (reach)</td><td>Low</td><td>P2</td></tr>
<tr><td>O39</td><td></strong>Multi-cloud redundancy appeals to data-conscious users<strong></td><td>High (trust)</td><td>Medium</td><td>P2</td></tr>
</table>
<hr>
<h2>18. Dependencies on Existing Plan</h2>
<h3>18.1 Must Complete First</h3>
<li>[ ] </strong>Phase 2 REST API<strong> (in progress): Foundation for memory API</li>
<li>[ ] </strong>Oban integration<strong> (in progress): Required for background jobs</li>
<li>[ ] </strong>Caching layer<strong> (Phase 3): Performance for search</li>
<li>[ ] </strong>Asset Storage System<strong> (see <code>roadmap/asset_storage_plan.md</code>): Foundation for media handling</li>
<h3>18.2 Can Proceed in Parallel</h3>
<li>[ ] </strong>Tagging<strong> (Phase 3): Useful but not blocking</li>
<li>[ ] </strong>Public IDs<strong> (Phase 3): Not directly related</li>
<li>[ ] </strong>Xamlr/blogging<strong> (post-MVP): Separate initiative</li>
<h3>18.4 Future Features (Post-MVP)</h3>
<li>[ ] </strong>BYOB Paid Plan UI<strong>: User-facing settings for connecting their own buckets</li>
<li>[ ] </strong>Multi-Cloud Redundancy<strong>: Users can configure multiple cloud backends (e.g., R2 + B2) for asset redundancy</li>
<li>[ ] </strong>GCS Backend<strong>: Google Cloud Storage support</li>
<h3>18.3 May Need Revision</h3>
<li>[ ] </strong>Full-text search implementation<strong>: Integrate with hybrid search</li>
<li>[ ] </strong>Representation versioning<strong>: Consider memory-specific needs</li>
<li>[ ] </strong>API rate limiting<strong>: May need memory-specific limits</li>
<li>[ ] </strong>Asset table schema<strong>: Add fields for E2EE, sync_mode, cloud_backend</li>
<hr>
<h2>19. Phasing & Prioritization</h2>
<h3>Phase 2.5: AI Memory Foundation (Storage Layer)</h3>
</strong>Goal<strong>: Minimum viable memory </strong>storage<strong> backend for AI agents
</strong>Core API Capabilities (Onelist provides):<strong>
<li>[ ] Add pgvector extension</li>
<li>[ ] Implement <code>embeddings</code> table and schema</li>
<li>[ ] Memory-specific entry types validation</li>
<li>[ ] API: Store entries with agent-provided embeddings</li>
<li>[ ] API: FTS search endpoint</li>
<li>[ ] API: Vector similarity search endpoint</li>
<li>[ ] API: Combined search endpoint (agents orchestrate weighting)</li>
<li>[ ] API: Bulk write operations</li>
</strong>NOT in Core (agents provide):<strong>
<li>~~Embedding generation~~ → OpenClaw/Searcher daemon does this</li>
<li>~~Compaction logic~~ → OpenClaw/Reader daemon does this</li>
<li>~~Relevance scoring~~ → Agents calculate, store in metadata</li>
</strong>Exit Criteria<strong>: Agents can store memories with embeddings and search via API
<h3>Phase 3: Memory Management APIs</h3>
</strong>Goal<strong>: Full API surface for agent-driven memory management
</strong>Core API Capabilities (Onelist provides):<strong>
<li>[ ] API: Archive/soft-delete entries</li>
<li>[ ] API: Entry linking (for summaries → sources)</li>
<li>[ ] API: Metadata bulk update (for relevance scores)</li>
<li>[ ] API: Access logging (track what's retrieved)</li>
<li>[ ] API: Bulk read with filters (for compaction queries)</li>
<li>[ ] Webhook events for entry changes (agents subscribe)</li>
</strong>Reference Implementations (separate from Core):<strong>
<li>[ ] OpenClaw skill reference implementation</li>
<li>[ ] Optional: Onelist Searcher daemon (embedding-as-a-service)</li>
<li>[ ] Optional: Onelist Reader daemon (summarization-as-a-service)</li>
<li>[ ] Import tools (OpenClaw file format → Onelist API)</li>
</strong>Exit Criteria<strong>: Full memory lifecycle possible via API; reference OpenClaw integration works
<h3>Phase 4: Sync & Encryption</h3>
</strong>Goal<strong>: Multi-device with E2EE
<li>[ ] Encryption layer implementation</li>
<li>[ ] Key derivation and management</li>
<li>[ ] Sync protocol implementation</li>
<li>[ ] Conflict detection and resolution</li>
<li>[ ] Cloud sync endpoints</li>
<li>[ ] Multi-client testing</li>
</strong>Exit Criteria<strong>: Two local instances can sync via cloud; E2EE verified
<h3>Phase 5: Hosted Service</h3>
</strong>Goal<strong>: Launch cloud offering
<li>[ ] Cloud infrastructure setup</li>
<li>[ ] Account management</li>
<li>[ ] Billing integration</li>
<li>[ ] Monitoring and alerting</li>
<li>[ ] Documentation</li>
<li>[ ] Open source release</li>
</strong>Exit Criteria<strong>: Public launch of both open source and hosted service
<hr>
<h2>20. Supermemory-Inspired Optimizations</h2>
</strong>Reference<strong>: Based on analysis of <a href="https://supermemory.ai/research">Supermemory.ai</a> state-of-the-art memory architecture (January 2026).
<h3>20.1 Key Insights from Supermemory</h3>
<p>Supermemory achieves superior performance on <a href="https://github.com/xiaowu0162/LongMemEval">LongMemEval</a> benchmark:
<li>Multi-Session Reasoning: </strong>71.43%<strong></li>
<li>Temporal Reasoning: </strong>76.69%<strong></li></p>
<p>Their key innovations that Onelist should adopt:</p>
<h4>20.1.1 Atomic Memory Generation</h4>
</strong>Problem<strong>: Standard RAG chunks content but doesn't extract discrete facts. Chunks contain noise and ambiguous references ("he said", "yesterday").
</strong>Supermemory Solution<strong>: Generate </strong>atomic memories<strong>—single pieces of information with resolved references—from each chunk.
<pre><code class="language-">Standard RAG:                    Supermemory Approach:
─────────────                    ────────────────────
[Document] →                     [Document] →
  [Chunk 1] (noisy)                [Chunk 1] → [Memory: &quot;John prefers Python&quot;]
  [Chunk 2] (noisy)                          → [Memory: &quot;Meeting scheduled for 2026-01-28&quot;]
                                   [Chunk 2] → [Memory: &quot;Project deadline is Q2 2026&quot;]
</code></pre>
<h4>20.1.2 Two-Layer Retrieval</h4>
</strong>Problem<strong>: Searching on raw chunks returns noisy, ambiguous results.
</strong>Supermemory Solution<strong>:
1. </strong>Search<strong> on atomic memories (high signal, low noise → high precision)
2. </strong>Return<strong> original source chunk alongside memory (preserves context/nuance)
<pre><code class="language-">Query: &quot;When is the project deadline?&quot;
<p>Step 1 - Search atomic memories:
  → Hit: &quot;Project deadline is Q2 2026&quot; (memory_id: abc123)
  → Score: 0.95</p>
<p>Step 2 - Inject source chunk:
  → Return memory + original chunk context
  → LLM gets both precise fact AND surrounding context
</code></pre></p>
<h4>20.1.3 Semantic Relationship Tracking</h4>
</strong>Problem<strong>: Facts evolve over time. "My favorite color is blue" may be superseded by "My favorite color is green".
</strong>Supermemory Solution<strong>: Track relationships between memories:
<li></strong>Supersedes (State Mutation)<strong>: New info replaces old</li>
<li></strong>Refines (Extension)<strong>: Adds detail without contradiction</li>
<li></strong>Contradicts<strong>: Conflicting information requiring resolution</li>
<h3>20.2 Implementation Plan for Onelist</h3>
<h4>20.2.1 New <code>memories</code> Table (Atomic Memories)</h4>
<pre><code class="language-sql">CREATE TABLE memories (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  entry_id UUID REFERENCES entries(id) ON DELETE CASCADE,
  representation_id UUID REFERENCES representations(id),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
<p>-- Atomic memory content
  content TEXT NOT NULL,                         -- Single atomic fact/observation
  memory_type VARCHAR(50) NOT NULL,              -- 'fact', 'preference', 'event', 'observation'
  confidence DECIMAL(3,2) DEFAULT 1.0,           -- Extraction confidence</p>
<p>-- Vector for high-precision retrieval
  embedding vector(1536),</p>
<p>-- Temporal context (resolved)
  valid_from TIMESTAMPTZ,                        -- When this became true
  valid_until TIMESTAMPTZ,                       -- When superseded (null = current)
  temporal_expression TEXT,                      -- Original: &quot;yesterday&quot;, &quot;last week&quot;
  resolved_time TIMESTAMPTZ,                     -- Resolved: actual datetime</p>
<p>-- Source tracking
  source_text TEXT,                              -- Original text this was extracted from
  source_start_offset INTEGER,
  source_end_offset INTEGER,</p>
<p>-- Relationships
  supersedes_id UUID REFERENCES memories(id),   -- For updates/corrections
  refines_id UUID REFERENCES memories(id),      -- For extensions</p>
<p>-- Metadata
  extraction_model VARCHAR(100),                 -- Model that extracted this
  metadata JSONB,
  inserted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);</p>
<p>CREATE INDEX memories_user_id_idx ON memories(user_id);
CREATE INDEX memories_entry_id_idx ON memories(entry_id);
CREATE INDEX memories_embedding_idx ON memories
  USING hnsw (embedding vector_cosine_ops) WITH (m = 16, ef_construction = 64);
CREATE INDEX memories_temporal_idx ON memories(user_id, valid_from, valid_until)
  WHERE valid_until IS NULL;  -- Current memories
CREATE INDEX memories_supersedes_idx ON memories(supersedes_id);
</code></pre></p>
<h4>20.2.2 Reader Agent Responsibilities (Enhanced)</h4>
<p>The Reader Agent becomes responsible for atomic memory generation:</p>
<pre><code class="language-elixir">defmodule Onelist.Reader.AtomicMemoryExtractor do
  @moduledoc &quot;&quot;&quot;
  Extracts atomic memories from entry content.
  &quot;&quot;&quot;
<p>def extract_memories(entry, representation) do
    # 1. Chunk the content
    chunks = chunk_content(representation.content)</p>
<p># 2. For each chunk, extract atomic memories
    memories = Enum.flat_map(chunks, fn chunk -&gt;
      extract_from_chunk(chunk, entry)
    end)</p>
<p># 3. Resolve references
    resolved = resolve_references(memories, entry)</p>
<p># 4. Detect relationships with existing memories
    with_relationships = detect_relationships(resolved, entry.user_id)</p>
<p># 5. Store memories
    store_memories(with_relationships)
  end</p>
<p>defp extract_from_chunk(chunk, entry) do
    prompt = &quot;&quot;&quot;
    Extract atomic facts from this text. Each fact should:
    <li>Be a single, self-contained piece of information</li>
    <li>Resolve pronouns (he/she/they → actual names if known)</li>
    <li>Resolve relative times (yesterday → actual date: #{Date.to_string(entry.content_created_at)})</li>
    <li>Be independently understandable without the source text</li></p>
<p>Text: #{chunk.text}</p>
<p>Entry context:
    <li>Title: #{entry.title}</li>
    <li>Created: #{entry.content_created_at}</li>
    <li>Tags: #{Enum.join(entry.tags, &quot;, &quot;)}</li></p>
<p>Return JSON array of atomic facts with their types (fact/preference/event/observation).
    &quot;&quot;&quot;</p>
<p>LLM.extract_structured(prompt, schema: memory_schema())
  end</p>
<p>defp detect_relationships(memories, user_id) do
    Enum.map(memories, fn memory -&gt;
      # Find similar existing memories
      similar = search_similar_memories(memory.content, user_id, limit: 5)</p>
<p># Detect relationship type
      relationship = classify_relationship(memory, similar)</p>
<p>case relationship do
        {:supersedes, old_memory_id} -&gt;
          Map.put(memory, :supersedes_id, old_memory_id)
        {:refines, old_memory_id} -&gt;
          Map.put(memory, :refines_id, old_memory_id)
        :new -&gt;
          memory
      end
    end)
  end
end
</code></pre></p>
<h4>20.2.3 Searcher Agent Enhancements (Two-Layer Retrieval)</h4>
<pre><code class="language-elixir">defmodule Onelist.Searcher.TwoLayerSearch do
  @moduledoc &quot;&quot;&quot;
  Two-layer retrieval: search atomic memories, inject source chunks.
  &quot;&quot;&quot;
<p>def search(user_id, query, opts \\ []) do
    limit = Keyword.get(opts, :limit, 20)
    include_source = Keyword.get(opts, :include_source_chunks, true)</p>
<p># Layer 1: High-precision search on atomic memories
    memory_hits = search_memories(user_id, query, limit: limit * 3)</p>
<p># Layer 2: For each hit, fetch original source
    results = if include_source do
      Enum.map(memory_hits, fn hit -&gt;
        source_rep = get_representation(hit.representation_id)
        source_entry = get_entry(hit.entry_id)</p>
<p>%{
          memory: hit,                           # Atomic fact
          source_chunk: extract_chunk(source_rep, hit), # Original context
          source_entry: %{
            id: source_entry.id,
            title: source_entry.title,
            entry_type: source_entry.entry_type,
            created_at: source_entry.content_created_at
          },
          score: hit.score
        }
      end)
    else
      memory_hits
    end</p>
<p># Deduplicate by source entry
    results
    |&gt; deduplicate_by_entry()
    |&gt; Enum.take(limit)
  end</p>
<p>defp extract_chunk(representation, memory) do
    if memory.source_start_offset &amp;&amp; memory.source_end_offset do
      String.slice(
        representation.content,
        memory.source_start_offset,
        memory.source_end_offset - memory.source_start_offset
      )
    else
      representation.content
    end
  end
end
</code></pre></p>
<h4>20.2.4 Enhanced Search API</h4>
<pre><code class="language-">POST /api/v1/memory/search
{
  &quot;query&quot;: &quot;when is the project deadline&quot;,
  &quot;search_mode&quot;: &quot;atomic&quot;,              # NEW: &quot;atomic&quot; (memories), &quot;chunk&quot; (legacy), &quot;hybrid&quot;
  &quot;include_source_chunks&quot;: true,        # NEW: inject original context
  &quot;temporal_filter&quot;: {                  # NEW: temporal reasoning
    &quot;relative&quot;: &quot;last_30_days&quot;,
    &quot;reasoning&quot;: true
  },
  &quot;filters&quot;: {
    &quot;memory_types&quot;: [&quot;fact&quot;, &quot;event&quot;],
    &quot;entry_types&quot;: [&quot;note&quot;, &quot;meeting&quot;],
    &quot;current_only&quot;: true                # Only non-superseded memories
  },
  &quot;limit&quot;: 20
}
<p>Response:
{
  &quot;results&quot;: [
    {
      &quot;memory&quot;: {
        &quot;id&quot;: &quot;...&quot;,
        &quot;content&quot;: &quot;Project deadline is Q2 2026&quot;,
        &quot;memory_type&quot;: &quot;fact&quot;,
        &quot;confidence&quot;: 0.95,
        &quot;valid_from&quot;: &quot;2026-01-15T00:00:00Z&quot;,
        &quot;supersedes_id&quot;: null
      },
      &quot;source_chunk&quot;: &quot;In our planning meeting, we discussed timelines. The project deadline is Q2 2026, but we may have a soft launch in Q1.&quot;,
      &quot;source_entry&quot;: {
        &quot;id&quot;: &quot;...&quot;,
        &quot;title&quot;: &quot;Project Planning Meeting Notes&quot;,
        &quot;entry_type&quot;: &quot;note&quot;,
        &quot;created_at&quot;: &quot;2026-01-15T10:30:00Z&quot;
      },
      &quot;score&quot;: 0.95
    }
  ],
  &quot;search_mode&quot;: &quot;atomic&quot;,
  &quot;total&quot;: 1
}
</code></pre></p>
<h3>20.3 Agent Responsibility Split</h3>
<table>
<tr><th>Capability</th><th>Onelist Core</th><th>Reader Agent</th><th>Searcher Agent</th></tr>
<tr><td>Store memories</td><td>✅ CRUD API</td><td>Calls API</td><td>Calls API</td></tr>
<tr><td>Store embeddings</td><td>✅ Vector column</td><td>—</td><td>Generates, stores</td></tr>
<tr><td></strong>Extract atomic memories<strong></td><td>—</td><td>✅ </strong>NEW<strong></td><td>—</td></tr>
<tr><td></strong>Resolve references<strong></td><td>—</td><td>✅ </strong>NEW<strong></td><td>—</td></tr>
<tr><td></strong>Detect relationships<strong></td><td>—</td><td>✅ </strong>NEW<strong></td><td>—</td></tr>
<tr><td>Chunk content</td><td>—</td><td>✅</td><td>Also for embeddings</td></tr>
<tr><td>Generate embeddings</td><td>—</td><td>—</td><td>✅</td></tr>
<tr><td></strong>Two-layer retrieval<strong></td><td>—</td><td>—</td><td>✅ </strong>NEW<strong></td></tr>
<tr><td></strong>Temporal reasoning<strong></td><td>—</td><td>—</td><td>✅ </strong>NEW<strong></td></tr>
<tr><td>Compaction/summarization</td><td>—</td><td>✅</td><td>—</td></tr>
<tr><td>Tag suggestions</td><td>—</td><td>✅</td><td>—</td></tr>
</table>
<h3>20.4 OpenClaw Integration Benefits</h3>
<p>With these optimizations, OpenClaw gets significant improvements:</p>
<table>
<tr><th>Current Pain Point</th><th>Supermemory-Inspired Solution</th></tr>
<tr><td>"$11 for 'Hi'" (token bloat)</td><td>Atomic memories are token-efficient; source chunks only when needed</td></tr>
<tr><td>Fuzzy search misses</td><td>High-precision atomic memory search</td></tr>
<tr><td>"When did I..." questions fail</td><td>Temporal reasoning with resolved timestamps</td></tr>
<tr><td>Contradictory facts</td><td>Supersedes/refines relationships track evolution</td></tr>
<tr><td>Context pollution</td><td>Two-layer retrieval separates signal from noise</td></tr>
</table>
<h3>20.5 Implementation Priority</h3>
<table>
<tr><th>Priority</th><th>Component</th><th>Effort</th><th>Impact</th></tr>
<tr><td></strong>HIGH<strong></td><td><code>memories</code> table schema</td><td>1 day</td><td>Foundation</td></tr>
<tr><td></strong>HIGH<strong></td><td>Reader: Atomic memory extraction</td><td>3-4 days</td><td>Major accuracy improvement</td></tr>
<tr><td></strong>HIGH<strong></td><td>Reader: Reference resolution</td><td>2 days</td><td>Temporal + entity clarity</td></tr>
<tr><td></strong>HIGH<strong></td><td>Searcher: Two-layer retrieval</td><td>2 days</td><td>Better precision + context</td></tr>
<tr><td></strong>MEDIUM<strong></td><td>Reader: Relationship detection</td><td>2 days</td><td>Knowledge evolution</td></tr>
<tr><td></strong>MEDIUM<strong></td><td>Searcher: Temporal reasoning</td><td>2 days</td><td>"When" queries</td></tr>
<tr><td></strong>LOW<strong></td><td>LongMemEval benchmarking</td><td>1 day</td><td>Validation</td></tr>
</table>
<h3>20.6 Benchmark Validation</h3>
<p>Use <a href="https://github.com/xiaowu0162/LongMemEval">LongMemEval</a> and <a href="https://github.com/supermemoryai/memorybench">MemoryBench</a> to validate:</p>
<p>1. </strong>Information Extraction<strong>: Can we recall specific facts?
2. </strong>Multi-Session Reasoning<strong>: Can we connect information across sessions?
3. </strong>Temporal Reasoning<strong>: Can we answer "when" questions accurately?
4. </strong>Knowledge Updates<strong>: Do we handle corrections properly?
5. </strong>Abstention<strong>: Do we know when we don't know?</p>
<p>Target: Match or exceed Supermemory's LongMemEval scores.</p>
<hr>
<h2>21. Decision Log</h2>
<table>
<tr><th>Date</th><th>Decision</th><th>Rationale</th><th>Alternatives Considered</th></tr>
<tr><td>2026-01-28</td><td>Search only works locally</td><td>Enables true E2EE; simplifies architecture</td><td>Cloud search with searchable encryption (too complex)</td></tr>
<tr><td>2026-01-28</td><td>Cloud stores encrypted blobs only</td><td>Privacy differentiator; trust model</td><td>Cloud has access for "value-add" features</td></tr>
<tr><td>2026-01-28</td><td>Open source with hosted service model</td><td>First-mover advantage; community growth</td><td>Proprietary; pure OSS without hosting</td></tr>
<tr><td>2026-01-28</td><td>Support multiple AI agents, not just OpenClaw</td><td>Larger market; reduces dependency risk</td><td>OpenClaw-exclusive focus</td></tr>
<tr><td>2026-01-28</td><td></strong>Onelist Core = Storage; Intelligence = Agents<strong></td><td>Aligns with existing daemon architecture; keeps Core simple; agents can innovate independently</td><td>Embedding/compaction in Core (couples intelligence to storage)</td></tr>
<tr><td>2026-01-28</td><td>Agents generate their own embeddings</td><td>Privacy (agents use their own LLM); flexibility (different models); cost control</td><td>Core generates embeddings (adds LLM dependency to Core)</td></tr>
<tr><td>2026-01-28</td><td>Compaction is agent responsibility</td><td>Different agents need different strategies; OpenClaw has its own logic</td><td>Core compaction (one-size-fits-all approach)</td></tr>
<tr><td>2026-01-28</td><td>OpenClaw is "just another agent" in ecosystem</td><td>Fits existing architecture; reduces special-casing; proves API generality</td><td>OpenClaw-specific APIs/features</td></tr>
<tr><td>2026-01-28</td><td></strong>Sidecar architecture - files always primary<strong></td><td>Zero risk adoption; transparent failure; easy uninstall; user trust</td><td>Replacement architecture (intercept writes, DB as primary)</td></tr>
<tr><td>2026-01-28</td><td>File watcher mirrors to DB (one-way)</td><td>Files are source of truth; DB rebuildable; no lock-in</td><td>Two-way sync (complex, risky)</td></tr>
<tr><td>2026-01-28</td><td>Search augments, not replaces</td><td>Native search always works; Onelist adds semantic; graceful degradation</td><td>Replace native search (breaks if Onelist down)</td></tr>
<tr><td>2026-01-28</td><td>No migration needed</td><td>Install and go; file watcher syncs automatically; frictionless</td><td>Explicit import step (friction, risk perception)</td></tr>
<tr><td>2026-01-28</td><td></strong>Tiered storage - media as cloud stubs<strong></td><td>Local storage stays lean; search works on metadata; full media fetched on demand</td><td>Full sync everything (storage explosion)</td></tr>
<tr><td>2026-01-28</td><td>Database abstraction layer</td><td>Support SQLite (local) + PostgreSQL (server); same codebase</td><td>Single DB engine (limits deployment options)</td></tr>
<tr><td>2026-01-28</td><td>~~SQLite + sqlite-vec~~ → ~~SQLite + Vectorlite~~ → </strong>Embedded PostgreSQL everywhere<strong></td><td>Single codebase; pgvector battle-tested; no compromises; ~150MB acceptable on modern Macs</td><td>SQLite+Vectorlite (two codepaths, newer tech), sqlite-vec alone (too slow)</td></tr>
<tr><td>2026-01-28</td><td>Bundle PostgreSQL binaries in Mac app</td><td>Subprocess model works; Postgres.app proves viability; pgvector included</td><td>Require external PostgreSQL install (bad UX)</td></tr>
<tr><td>2026-01-28</td><td>Mac app with selectable agents</td><td>Users choose which agents run; different instances can specialize</td><td>All-or-nothing agent deployment</td></tr>
<tr><td>2026-01-28</td><td>Agents coordinate via cloud sync</td><td>No direct agent-to-agent communication; results sync via cloud</td><td>Direct agent communication (complex)</td></tr>
</table>
<hr>
<h2>Appendix A: Glossary</h2>
<li></strong>E2EE<strong>: End-to-end encryption</li>
<li></strong>DEK<strong>: Data Encryption Key</li>
<li></strong>FTS<strong>: Full-text search</li>
<li></strong>HNSW<strong>: Hierarchical Navigable Small World (vector index type)</li>
<li></strong>IVFFlat<strong>: Inverted File with Flat compression (vector index type)</li>
<li></strong>RRF<strong>: Reciprocal Rank Fusion</li>
<li></strong>Vector clock**: Logical clock for distributed systems sync</li>
<hr>
<h2>Appendix B: Reference Links</h2>
<li><a href="https://github.com/pgvector/pgvector">pgvector documentation</a></li>
<li><a href="https://github.com/steipete/openclaw">OpenClaw GitHub</a> (check for current URL)</li>
<li><a href="https://github.com/danielberkompas/cloak">Cloak encryption library</a></li>
<li><a href="https://hexdocs.pm/oban">Oban documentation</a></li>
<li><a href="https://supermemory.ai">supermemory</a> (competitor reference)</li>
</ul>
<hr>
<em>This is a living document. Update as decisions are made and questions are resolved.</em>
  </article>
</body>
</html>
